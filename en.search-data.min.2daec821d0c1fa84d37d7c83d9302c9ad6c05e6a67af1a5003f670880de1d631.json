[{"id":0,"href":"/magic-modules/develop/test/test/","title":"Add resource tests","section":"Test","content":" Add resource tests # This page describes how to add tests to a new resource in the google or google-beta Terraform provider.\nFor more information about testing, see the official Terraform documentation.\nBefore you begin # Determine whether your resources is using MMv1 generation or handwritten. If you are not adding tests to an in-progress PR, ensure that your magic-modules, terraform-provider-google, and terraform-provider-google-beta repositories are up to date. cd ~/magic-modules git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull Add a create test # A create test is a test that creates the target resource and immediately destroys it.\nNote: All resources should have a \u0026ldquo;basic\u0026rdquo; create test, which uses the smallest possible number of fields. Additional create tests can be used to ensure all fields on the resource are used in at least one test.\nMMv1 Using an editor of your choice, create a *.tf.erb file in mmv1/templates/terraform/examples/. The name of the file should include the service name, resource name, and a descriptor. For example, compute_subnetwork_basic.tf.erb. Write the Terraform configuration for your test. This should include all of the required dependencies. For example, google_compute_subnetwork has a dependency on google_compute_network: resource \u0026#34;google_compute_subnetwork\u0026#34; \u0026#34;primary\u0026#34; { name = \u0026#34;my-subnet\u0026#34; ip_cidr_range = \u0026#34;10.1.0.0/16\u0026#34; region = \u0026#34;us-central1\u0026#34; network = google_compute_network.network.name } resource \u0026#34;google_compute_network\u0026#34; \u0026#34;network\u0026#34; { name = \u0026#34;my-network\u0026#34; auto_create_subnetworks = false } If beta-only fields are being tested: Add provider = google-beta to every resource in the file. Modify the configuration to use templated values. Replace the id of the primary resource you are testing with \u0026lt;%= ctx[:primary_resource_id] %\u0026gt;. Replace fields that are identifiers, like id or name, with an appropriately named variable. For example, \u0026lt;%= ctx[:vars]['subnetwork_name'] %\u0026gt;. The resulting configuration for the above example would look like this: resource \u0026#34;google_compute_subnetwork\u0026#34; \u0026#34;\u0026lt;%= ctx[:primary_resource_id] %\u0026gt;\u0026#34; { name = \u0026#34;\u0026lt;%= ctx[:vars][\u0026#39;subnetwork_name\u0026#39;] %\u0026gt;\u0026#34; ip_cidr_range = \u0026#34;10.1.0.0/16\u0026#34; region = \u0026#34;us-central1\u0026#34; network = google_compute_network.network.name } resource \u0026#34;google_compute_network\u0026#34; \u0026#34;network\u0026#34; { name = \u0026#34;\u0026lt;%= ctx[:vars][\u0026#39;network_name\u0026#39;] %\u0026gt;\u0026#34; auto_create_subnetworks = false } Modify the relevant RESOURCE_NAME.yaml file under magic-modules/mmv1/products to include an examples block with your test. The name must match the name of your *.tf.erb file. For example: examples: - !ruby/object:Provider::Terraform::Examples name: \u0026#34;compute_subnetwork_basic\u0026#34; primary_resource_id: \u0026#34;example\u0026#34; vars: subnetwork_name: \u0026#34;example-subnet\u0026#34; network_name: \u0026#34;example-network\u0026#34; Warning: Values in vars must include a - (or _). They trigger the addition of a tf-test prefix, which the sweeper uses to clean them up after tests run. If beta-only fields are being tested: Add min_version: beta to the examples block in RESOURCE_NAME.yaml. Handwritten This section assumes you\u0026rsquo;ve used the Add a resource guide to create your handwritten resource, and you have a working MMv1 config.\nNote: If not, you can create one now, or skip this guide and construct the test by hand. Writing tests by hand can sometimes be a better option if there is a similar test you can copy from.\nAdd the test in MMv1. Repeat for all the create tests you will need. Generate the beta provider. From the beta provider, copy and paste the generated *_generated_test.go file into the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services as a new file call *_test.go. Modify the tests as needed. Replace all occurrences of github.com/hashicorp/terraform-provider-google-beta/google-beta with github.com/hashicorp/terraform-provider-google/google Remove the comments at the top of the file. Remove the Example suffix from all function names. If beta-only fields are being tested, do the following: Change the file suffix to .go.erb Add \u0026lt;% autogen_exception -%\u0026gt; to the top of the file Wrap each beta-only test in a separate version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt; Add an update test # An update test is a test that creates the target resource and then makes updates to fields that are updatable. Updatable fields are fields that can be updated without recreating the entire resource; that is, they are not marked immutable in MMv1 or ForceNew in handwritten code.\nNote: All updatable fields must be covered by at least one update test. In most cases, only a single update test is needed to test all fields at once.\nMMv1 Generate the beta provider. From the beta provider, copy and paste the generated *_generated_test.go file into the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services as a new file call *_test.go. Using an editor of your choice, delete the *DestroyProducer function, and all but one test. The remaining test should be the \u0026ldquo;full\u0026rdquo; test, or if there is no \u0026ldquo;full\u0026rdquo; test, the \u0026ldquo;basic\u0026rdquo; test. This will be the starting point for your new update test. Modify the TestAcc* test function to support updates. Change the suffix of the test function to _update. Copy the 2 TestStep blocks and paste them immediately after, so that there are 4 total test steps. Change the suffix of the first Config value to _full (or _basic). Change the suffix of the second Config value to _update. The resulting test function would look similar to this: func TestAccPubsubTopic_update(t *testing.T) { ... acctest.VcrTest(t, resource.TestCase{ ... Steps: []resource.TestStep{ { Config: testAccPubsubTopic_full(...), }, { ... }, { Config: testAccPubsubTopic_update(...), }, { ... }, }, }) } Modify the testAcc* Terraform template function to support updates. Copy the template function and paste it immediately after so that there are 2 template functions. Change the suffix of the first template function to _full (or _basic). Change the suffix of the second template function to _update. The resulting template functions would look similar to this: func testAccPubsubTopic_full(...) string { ... } func testAccPubsubTopic_update(...) string { ... } Modify the test as needed. Replace all occurrences of github.com/hashicorp/terraform-provider-google-beta/google-beta with github.com/hashicorp/terraform-provider-google/google Modify the template function ending in _update so that updatable fields are changed or removed. This may require additions to the context map in the test function. Remove the comments at the top of the file. If beta-only fields are being tested, do the following: Change the file suffix to .go.erb Add \u0026lt;% autogen_exception -%\u0026gt; to the top of the file Wrap each beta-only test in a separate version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt; In each beta-only test, ensure that the TestCase sets ProtoV5ProviderFactories: acctest.ProtoV5ProviderBetaFactories(t) In each beta-only test, ensure that all Terraform resources in all configs have provider = google-beta set Handwritten Using an editor of your choice, open the existing *_test.go or *_test.go.erb file in the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services which contains your create tests. Copy the TestAcc* test function for the existing \u0026ldquo;full\u0026rdquo; test. If there is no \u0026ldquo;full\u0026rdquo; test, use the \u0026ldquo;basic\u0026rdquo; test. This will be the starting point for your new update test. Modify the test function to support updates. Change the suffix of the test function to _update. Copy the 2 TestStep blocks and paste them immediately after, so that there are 4 total test steps. Change the suffix of the second Config value to _update. The resulting test function would look similar to this: func TestAccPubsubTopic_update(t *testing.T) { ... acctest.VcrTest(t, resource.TestCase{ ... Steps: []resource.TestStep{ { Config: testAccPubsubTopic_full(...), }, { ... }, { Config: testAccPubsubTopic_update(...), }, { ... }, }, }) } Add a Terraform template function to support updates. Copy the full (or basic) testAcc* template function. Change the suffix of the new template function to _update. The new template function would look similar to this: func testAccPubsubTopic_update(...) string { ... } Modify the test as needed. Modify the new template function so that updatable fields are changed or removed. This may require additions to the context map in the test function. Remove the comments at the top of the file. If beta-only fields are being tested, do the following: Change the file suffix to .go.erb Add \u0026lt;% autogen_exception -%\u0026gt; to the top of the file Wrap each beta-only test in a separate version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt; In each beta-only test, ensure that the TestCase sets ProtoV5ProviderFactories: acctest.ProtoV5ProviderBetaFactories(t) In each beta-only test, ensure that all Terraform resources in all configs have provider = google-beta set Add unit tests # A unit test verifies functionality that is not related to interactions with the API, such as diff suppress functions), validation functions, CustomizeDiff functions, and so on.\nUnit tests should be added to the appropriate folder in magic-modules/mmv1/third_party/terraform/services in the file called resource_PRODUCT_RESOURCE_test.go. (You may need to create this file if it does not already exist. Replace PRODUCT with the product name and RESOURCE with the resource name; it should match the name of the generated resource file.)\nUnit tests should be named like TestFunctionName - for example, TestDiskImageDiffSuppress would contain tests for the DiskImageDiffSuppress function.\nExample:\nfunc TestSignatureAlgorithmDiffSuppress(t *testing.T) { cases := map[string]struct { Old, New string ExpectDiffSuppress bool }{ \u0026#34;ECDSA_P256 equivalent\u0026#34;: { Old: \u0026#34;ECDSA_P256_SHA256\u0026#34;, New: \u0026#34;EC_SIGN_P256_SHA256\u0026#34;, ExpectDiffSuppress: true, }, // Additional cases excluded for brevity } for tn, tc := range cases { if signatureAlgorithmDiffSuppress(\u0026#34;signature_algorithm\u0026#34;, tc.Old, tc.New, nil) != tc.ExpectDiffSuppress { t.Errorf(\u0026#34;bad: %s, %q =\u0026gt; %q expect DiffSuppress to return %t\u0026#34;, tn, tc.Old, tc.New, tc.ExpectDiffSuppress) } } } What\u0026rsquo;s next? # Run your tests "},{"id":1,"href":"/magic-modules/contribute/create-pr/","title":"Create a pull request","section":"Contribute","content":" Create a pull request (PR) # Requirements # Make sure your branch contains a single self-contained change. For example: If you are adding multiple resources to the provider, only put one resource in each PR - even if the product requires all resources to be present before it can be meaningfully used. If you are adding a few fields and also fixing a bug, create one PR for adding the new fields and a separate PR for the bugs. Follow the instructions at Creating a pull request to create a pull request to merge your branch into GoogleCloudPlatform/magic-modules. Make sure the PR body includes the text Fixes GITHUB_ISSUE_LINK. once per issue resolved by your PR. Replace GITHUB_ISSUE_LINK with a link to a GitHub issue from the provider issue tracker. Write release notes Code review # A reviewer will automatically be assigned to your PR. Creating a new pull request or pushing a new commit automatically triggers our CI pipelines and workflows. After CI starts, downstream diff generation takes about 10 minutes; VCR tests can take up to 2 hours. If you are a community contributor, some tests will only run after approval from a reviewer. While convenient, relying on CI to test iterative changes to PRs often adds extreme latency to reviews if there are errors in test configurations or at runtime. We strongly recommend you test your changes locally before pushing even after the initial change. If your assigned reviewer does not respond to changes on a pull request within two US business days, ping them on the pull request. TIP: Speeding up review:\nTest your changes locally before pushing to iterate faster. You can push them and test in parallel as well. New CI runs will preempt old ones where possible. Resolve failed status checks quickly Directly ask your reviewer for help if you don\u0026rsquo;t know how to proceed. If there are failed checks they may only check in if there\u0026rsquo;s no progress after a couple days. Self-review your PR or ask someone else familiar with Terraform to review Troubleshoot status check failures # Provider unit tests or VCR tests # VCR test failures that do not immediately seem related to your PR are most likely safe to ignore unless your reviewer says otherwise.\nReview the \u0026ldquo;diff generation\u0026rdquo; report to make sure the generated code looks as expected. Check out the generated code for your PR to run tests and iterate locally. For handwritten code or custom code, you can iterate directly in the provider and then copy the changes to your magic-modules branch once you have resolved the issue. terraform-provider-google cd $GOPATH/src/github.com/hashicorp/terraform-provider-google git checkout -- . \u0026amp;\u0026amp; git clean -f google/ google-beta/ website/ git remote add modular-magician https://github.com/modular-magician/terraform-provider-google.git git fetch modular-magician git checkout modular-magician/auto-pr-PR_NUMBER make test make lint make testacc TEST=./google/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool\u0026#39; Replace PR_NUMBER with your PR\u0026rsquo;s ID.\nterraform-provider-google-beta cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git checkout -- . \u0026amp;\u0026amp; git clean -f google/ google-beta/ website/ git remote add modular-magician https://github.com/modular-magician/terraform-provider-google-beta.git git fetch modular-magician git checkout modular-magician/auto-pr-PR_NUMBER make test make lint make testacc TEST=./google/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool\u0026#39; Replace PR_NUMBER with your PR\u0026rsquo;s ID.\n"},{"id":2,"href":"/magic-modules/get-started/generate-providers/","title":"Generate the providers","section":"Get started","content":" Generate google and google-beta providers # This quickstart guides you through setting up your development environment, making a change to magic-modules, generating provider changes to the google and google-beta Terraform providers, and running tests related to the change.\nBefore you begin # Install the gcloud CLI. In the Google Cloud console, on the project selector page, select or create a Google Cloud project. Note: If you don\u0026rsquo;t already have a project to use for testing changes to the Terraform providers, create a project instead of selecting an existing poject. After you finish these steps, you can delete the project, removing all resources associated with the project. Go to project selector Make sure that billing is enabled for your Google Cloud project. Learn how to check if billing is enabled on a project. Set up your development environment # If you are familiar with Docker or Podman, you may want to use the experimental container-based environment instead of this section. Install git\nInstall rbenv, ensuring you follow both steps 1 and 2.\nUse rbenv to install ruby 3.1.0\nrbenv install 3.1.0 Install go\nInstall goimports\ngo install golang.org/x/tools/cmd/goimports@latest Install terraform\nClone the magic-modules repository\ncd ~ git clone https://github.com/GoogleCloudPlatform/magic-modules.git Run the following command from the root of your cloned magic-modules repository.\ncd magic-modules ./scripts/doctor Expected output if everything is installed properly:\nCheck for ruby in path... found! Check for go in path... found! Check for goimports in path... found! Check for git in path... found! Check for terraform in path... found! Check for make in path... found! Generate a provider change # In your cloned magic-modules repository, edit mmv1/products/pubsub/Topic.yaml to change the description for the schemaSettings field:\n- !ruby/object:Api::Type::NestedObject name: \u0026#39;schemaSettings\u0026#39; description: | UPDATED_DESCRIPTION Clone the google and google-beta provider repositories with the following commands:\ngit clone https://github.com/hashicorp/terraform-provider-google.git $GOPATH/src/github.com/hashicorp/terraform-provider-google git clone https://github.com/hashicorp/terraform-provider-google-beta.git $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta Generate changes for the google provider\nmake provider VERSION=ga OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; PRODUCT=pubsub Generate changes for the google-beta provider\nmake provider VERSION=beta OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google-beta\u0026#34; PRODUCT=pubsub Confirm that the expected changes were generated\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google git diff -U0 cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git diff -U0 In both cases, the changes should include:\ndiff --git a/google-beta/resource_pubsub_topic.go b/google-beta/resource_pubsub_topic.go --- a/google-beta/resource_pubsub_topic.go +++ b/google-beta/resource_pubsub_topic.go @@ -115 +115 @@ and is not a valid configuration.`, - Description: `Settings for validating messages published against a schema.`, + Description: `UPDATED_DESCRIPTION`, diff --git a/website/docs/r/pubsub_topic.html.markdown b/website/docs/r/pubsub_topic.html.markdown --- a/website/docs/r/pubsub_topic.html.markdown +++ b/website/docs/r/pubsub_topic.html.markdown @@ -146 +146 @@ The following arguments are supported: - Settings for validating messages published against a schema. + UPDATED_DESCRIPTION Note: There may be additional changes present due to specifying a PRODUCT= value or due to the magic-modules repository being out of sync with the provider repositories. This is okay as long as tests in the following section pass. Test changes # Set up application default credentials for Terraform\ngcloud auth application-default login export GOOGLE_USE_DEFAULT_CREDENTIALS=true Set required environment variables\nexport GOOGLE_PROJECT=PROJECT_ID export GOOGLE_REGION=us-central1 export GOOGLE_ZONE=us-central1-a Replace PROJECT_ID with the ID of your Google Cloud project.\nEnable required APIs\ngcloud config set project $GOOGLE_PROJECT gcloud services enable pubsub.googleapis.com gcloud services enable cloudkms.googleapis.com Run all linters\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google make lint cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta make lint Run all unit tests\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google make test cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta make test Run acceptance tests for Pub/Sub Topic\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google make testacc TEST=./google/services/pubsub TESTARGS=\u0026#39;-run=TestAccPubsubTopic_\u0026#39; cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta make testacc TEST=./google-beta/services/pubsub TESTARGS=\u0026#39;-run=TestAccPubsubTopic_\u0026#39; Troubleshoot # Too many open files # If you are getting “Too many open files” ulimit needs to be raised.\nMac OS ulimit -n 8192 Cleanup # Optional: Revoke credentials from the gcloud CLI. gcloud auth revoke What\u0026rsquo;s next # Learn about Magic Modules Learn about the contribution process Learn about make commands "},{"id":3,"href":"/magic-modules/get-started/","title":"Get started","section":"Overview","content":""},{"id":4,"href":"/magic-modules/reference/make-commands/","title":"make commands","section":"Reference","content":" make commands reference # magic-modules # make / make provider # Generates the code for the downstream google and google-beta providers.\nNote: Generation works best if the downstream provider has a commit checked out corresponding to the latest main branch commit that is present in your magic-modules working branch. This can generally be identified based on matching commit messages. Examples:\nmake provider VERSION=ga OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; make provider VERSION=beta OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google-beta\u0026#34; # Only generate a specific product (plus all common files) make provider VERSION=ga OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; PRODUCT=pubsub # Only generate only a specific resources for a product make provider VERSION=ga OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; PRODUCT=pubsub RESOURCE=Topic # Only generate common files, including all third_party code make provider VERSION=ga OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; PRODUCT=doesnotexist Arguments # OUTPUT_PATH: Required. The location you are generating provider code into. VERSION: Required. The version of the provider you are building into. Valid values are ga and beta. PRODUCT: Limits generations to the specified folder within mmv1/products or tpgtools/api. Handwritten files from mmv1/third_party/terraform are always generated into the downstream regardless of this setting, so you can provide a non-existant product name to generate only handwritten code. Required if RESOURCE is specified. RESOURCE: Limits generation to the specified resource within a particular product. For mmv1 resources, matches the resource\u0026rsquo;s name field (set in its configuration file).For tpgtools resources, matches the terraform resource name. ENGINE: Modifies make provider to only generate code using the specified engine. Valid values are mmv1 or tpgtools. (Providing tpgtools will still generate any prerequisite mmv1 files required for tpgtools.) Cleaning up old files # Magic Modules will only generate on top of whatever is in the downstream repository. This means that, from time to time, you may end up with stale files or changes in your downstream that cause compilation or tests to fail.\nYou can clean up by running the following command in your downstream repositories:\ngit checkout -- . \u0026amp;\u0026amp; git clean -f google/ google-beta/ website/ Container-based environment # This approach is in beta and still collecting feedback. Please file an issue if you encounter challenges. ./scripts/make-in-container.sh runs make with the provided arguments inside a container with all necessary dependencies preinstalled. It uses Docker if available and Podman otherwise. Like make, this script must be run in the root of a magic-modules repository clone.\nIf you run into any problems, please file an issue.\nBefore you begin # Ensure that GOPATH is set on your host machine.\nprintenv | grep GOPATH If not, add export GOPATH=$HOME/go to your terminal\u0026rsquo;s startup script and restart your terminal.\nClone the google and google-beta provider repositories with the following commands:\ngit clone https://github.com/hashicorp/terraform-provider-google.git $GOPATH/src/github.com/hashicorp/terraform-provider-google git clone https://github.com/hashicorp/terraform-provider-google-beta.git $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta Example # To build the google provider, run the following command in the root of a magic-modules repository clone:\n./scripts/make-in-container.sh \\ terraform VERSION=ga \\ OUTPUT_PATH=\u0026#34;$GOPATH/src/github.com/hashicorp/terraform-provider-google\u0026#34; "},{"id":5,"href":"/magic-modules/develop/breaking-changes/breaking-changes/","title":"Types of breaking changes","section":"Breaking changes","content":" Types of breaking changes # A \u0026ldquo;breaking change\u0026rdquo; is any change that requires an end user to modify a previously-valid configuration after a provider upgrade. In this context, a \u0026ldquo;valid configuration\u0026rdquo; is one that:\nIs considered syntactically correct by terraform validate Does not return an error during terraform apply Creates, updates, deletes, or does not modify resources Only manages resources that have not been altered with other tools, such as gcloud or Cloud Console. This document lists many types of breaking changes but may not be entirely comprehensive. Some types of changes that would normally be \u0026ldquo;breaking\u0026rdquo; may have specific mitigating circumstances that make them non-breaking.\nFor more information, see Make a breaking change.\nProvider-level breaking changes # Changing fundamental provider behavior such as: authentication environment variable usage restricting retry behavior Resource-level breaking changes # Removing or renaming a resource or datasource Changing resource ID format Terraform uses resource ID to read resource state from the API. Modification of the ID format will break the ability to parse the IDs from any deployments. Removing or altering resource import ID formats Automation written by end users may rely on specific import formats. Changes to default resource behavior Changing resource deletion behavior In limited cases changes may be permissible if the prior behavior could never succeed. Changing resource deletion to skip deleting the resource by default if delete was previously called Changing resource deletion to specify a force flag Adding a new field with a default different from the API default If an API default is expected to change- a breaking change for the API- use default_from_api which will avoid sending a value and safely take the server default in Terraform Field-level breaking changes # Removing or renaming a field Changing field output type Between primitive types, like changing a String to an Integer Between complex types like changing a List to a Set. Changing the field type between primitive and complex data types is not possible. For this scenario, field renames are preferred. Making an optional field required or adding a new required field Making a settable field read-only For MMv1 resources, adding output: true to an existing field. For handwritten resources, adding Computed: true to a field that does not have Optional: true set. Removing support for API-side defaults For MMv1 resources, removing default_from_api: true. For handwritten resources, altering a field schema with Computed: true + Optional: true to only have Optional: true. Adding or changing a default value Default values in Terraform are used to replace null values in configuration at plan/apply time and do not respect previously-configured values by the user. Even in major releases, these changes are often undesirable, as their impact is extremely broad.\nWhen a default is changed, every user that has not specified an explicit value in their configuration will see Terraform propose changing the value of the field including if the change will destroy and recreate the resource due to changing an immutable value. Default changes in the provider are comparable in impact to default changes in an API, and modifying examples and modules may achieve the intended effect with a smaller blast radius.\nModifying how field data is stored in state For example, changing the case of a value returned by the API in a flattener or decorder Removing diff suppression from a field. For MMv1 resources, removing diff_suppress_func from a field. For handwritten resources, removing DiffSuppressFunc from a field. Removing update support from a field. Making validation more strict # Increasing the minimum number of items in an array For MMv1 resources, increasing min_size on an Array field. For handwritten resources, increasing MinItems on an Array field. Decreasing the maximum number of items in an array For MMv1 resources, decreasing max_size on an Array field. For handwritten resources, decreasing MaxItems on an Array field. Adding validation to a field that previously had no validation For MMv1 resources, adding validation to a field. For handwritten resources, adding ValidateFunc to a field. "},{"id":6,"href":"/magic-modules/develop/","title":"Develop","section":"Overview","content":""},{"id":7,"href":"/magic-modules/get-started/how-magic-modules-works/","title":"How Magic Modules works","section":"Get started","content":" How Magic Modules works # Magic Modules can be thought of as a source of truth for how to map a GCP API resource representation to a Terraform resource (or datasource) representation. Magic Modules uses that mapping (and additional handwritten code where necessary) to generate \u0026ldquo;downstream\u0026rdquo; repositories - in particular, the Terraform providers for Google Cloud: google (or TPG) and google-beta (or TPGB).\nGeneration of the downstream repositories happens for every new commit in a PR (to a temporary branch owned by the modular-magician robot user) and on every merge into the main branch (to the main branch of downstreams). Generation for PR commits allows contributors to manually examine the changes, as well as allowing automatic running of unit tests, acceptance tests, and automated checks such as breaking change detection.\nResource types # There are three types of resources supported by Magic Modules: MMv1, Handwritten, and DCL/tpgtools. These are described in more detail in the following sections.\nMMv1 # MMv1 consists of a set of \u0026ldquo;products\u0026rdquo;; each product contains one or more \u0026ldquo;resources\u0026rdquo;.\nEach product has a folder in magic-modules/mmv1/products. The name of the folder is the \u0026ldquo;product name\u0026rdquo;, which usually corresponds to the API subdomain covered by the product (such as compute.googleapis.com). Each product folder contains a product configuration file (product.yaml) and one or more resource configuration files (ResourceName.yaml). The actual name of a ResourceName.yaml file usually matches the name of a GCP API resource in the product\u0026rsquo;s subdomain.\nMMv1 resource configurations may reference handwritten code stored in magic-modules/mmv1/templates/terraform, which will be injected into the generated resource file. Many MMv1 resources also have one or more handwritten tests, which are stored in the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services\nIn the providers, MMv1-based resources are stored in PROVIDER/services/PRODUCT/resource_PRODUCT_RESOURCE.go, where PROVIDER is google or google-beta, PRODUCT is the product name, and RESOURCE is the GCP API resource\u0026rsquo;s name converted to snake case ↗.\nMMv1-based files start with the following header:\n*** AUTO GENERATED CODE *** Type: MMv1 *** Handwritten # Handwritten resources and datasources are technically part of MMv1; however, they are not generated from YAML configurations. Instead, they are written as Go code with minimal ruby \u0026ldquo;version guards\u0026rdquo; to exclude beta-only features from the google provider.\nHandwritten resources and datasources can be grouped by \u0026ldquo;service\u0026rdquo;, which generally corresponds to the API subdomain the resource or datasource interacts with.\nIn addition to the core implementation, handwritten resources and datasources will also have documentation, tests, and sweepers (which clean up stray resources left behind by tests). Each type of code is stored in the following locations:\nResource \u0026amp; datasource implementation: In the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services Resource documentation: magic-modules/mmv1/third_party/terraform/website/docs/r Datasource documentation: magic-modules/mmv1/third_party/terraform/website/docs/d Tests: In the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services Sweepers: magic-modules/mmv1/third_party/terraform/utils In the providers, handwritten resources and datasources are stored in PROVIDER/services/SERVICE/FILENAME.go, where PROVIDER is google or google-beta, SERVICE is the service name, and FILENAME is the name of the handwritten file in magic-modules. Handwritten files do not have an AUTO GENERATED CODE header.\nDCL aka tpgtools (maintenance mode) # DCL / tpgtools is similar to MMv1; however, it is in maintenance mode, which means that new resources using the DCL are not being added.\nDCL-based files start with the following header:\n*** AUTO GENERATED CODE *** Type: DCL *** "},{"id":8,"href":"/magic-modules/develop/breaking-changes/make-a-breaking-change/","title":"Make a breaking change","section":"Breaking changes","content":" Make a breaking change # A \u0026ldquo;breaking change\u0026rdquo; is any change that requires an end user to modify any previously-valid configuration after a provider upgrade. For more information, see Types of breaking changes.\nThe google and google-beta providers are both considered \u0026ldquo;stable surfaces\u0026rdquo; for the purpose of releases, which means that neither provider allows breaking changes except during major releases, which are typically yearly.\nTerraform users rely on the stability of Terraform providers (including the Google Cloud provider and other major providers.) Even as part of a major release, breaking changes that are overly broad and/or have little benefit to users can cause deeply negative reactions and significantly delay customers upgrading to the new major version.\nBreaking changes may cause significant churn for users by forcing them to update their configurations. It also causes churn in tooling built on top of the providers, such as:\nTerraform modules that use google or google-beta resources Policy tools like gcloud terraform vet There may also be churn in customer policies Config Connector Pulumi GCP Classic This page covers the general process to make a breaking change. It does not include exact, comprehensive details on how to make every potential breaking change. Breaking changes are complicated; the exact process and implementation may vary drastically depending on the implementation of the impacted resource or field and the change being made.\nIn minor releases # If a breaking change fixes a bug that impacts all configurations that include a field or resource, it is generally allowed in a minor release. For example:\nRemoving update support from a field if that field is not actually updatable in the API. Marking a field required if omitting the field always causes an API error. The following types of changes can be made if the default behavior stays the same and new behavior can be enabled with a flag:\nMajor resource-level or field-level behavioural changes In the 5.0.0 major release # The general process for contributing a breaking change to the 5.0.0 major release is:\nMake the main branch forwards-compatible with the major release Add deprecations and warnings to the main branch of magic-modules Add upgrade guide entries to the main branch of magic-modules Make the breaking change on FEATURE-BRANCH-major-release-5.0.0 These are covered in more detail in the following sections. The upgrade guide and the actual breaking change will be merged only after both are completed.\nMake the main branch forwards-compatible with the major release # What forwards-compatibility means will vary depending on the breaking change. For example:\nIf a required field is being removed, make the field optional on the main branch. If a field is being renamed, the new field must be added to the main branch Add deprecations and warnings to the main branch of magic-modules # Deprecations and warnings must be actionable at the time that they are added to the main branch, and they must be added prior to the 5.0.0 major release. Every deprecation or warning should be surfaced to users of the provider at runtime as well as in documentation.\nField deprecation (due to removal or rename) # MMv1 Set deprecation_message on the field. For example:\n- !ruby/object:Api::Type::String name: \u0026#39;apiFieldName\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION deprecation_message: \u0026#34;`api_field_name` is deprecated and will be removed in a future major release. Use `other_field_name` instead.\u0026#34; Replace the second sentence with an appropriate short description of the replacement path and/or the reason for deprecation.\nThe deprecation message will automatically show up in the resource documentation.\nHandwritten Set Deprecated on the field. For example:\n\u0026#34;api_field_name\u0026#34;: { Type: schema.String, Deprecated: \u0026#34;`api_field_name` is deprecated and will be removed in a future major release. Use `other_field_name` instead.\u0026#34;, ... } Replace the second sentence with an appropriate short description of the replacement path and/or the reason for deprecation.\nUpdate the documentation for the field to include the deprecation notice. For example:\n* `api_field_name` - (Optional, [Beta](https://terraform.io/docs/providers/google/guides/provider_versions.html), Deprecated) FIELD_DESCRIPTION. `api_field_name` is deprecated and will be removed in a future major release. Use `other_field_name` instead. Resource deprecation (due to removal or rename) # MMv1 Set deprecation_message on the resource. For example:\ndeprecation_message: \u0026gt;- `google_RESOURCE_NAME` is deprecated and will be removed in a future major release. Use `google_OTHER_RESOURCE_NAME` instead. Replace RESOURCE_NAME with the name of the resource (excluding the google_ prefix). Replace the second sentence with an appropriate short description of the replacement path and/or the reason for deprecation.\nThe deprecation message will automatically show up in the resource documentation.\nHandwritten Set DeprecationMessage on the field. For example:\nreturn \u0026amp;schema.Resource{ ... DeprecationMessage: \u0026#34;`google_RESOURCE_NAME` is deprecated and will be removed in a future \u0026#34; + \u0026#34;major release. Use `google_OTHER_RESOURCE_NAME` instead.\u0026#34;, ... } Replace RESOURCE_NAME with the name of the resource (excluding the google_ prefix). Replace the second sentence with an appropriate short description of the replacement path and/or the reason for deprecation.\nAdd a warning to the resource documentation stating that the resource is deprecated. For example:\n~\u0026gt; **Warning:** `google_RESOURCE_NAME` is deprecated and will be removed in a future major release. Use `google_OTHER_RESOURCE_NAME` instead. Other breaking changes # Other breaking changes should be called out in the docs for the impacted field or resource. It is also great to log warnings at runtime if possible.\nAdd upgrade guide entries to the main branch of magic-modules # Upgrade guide entries should be added to version_5_upgrade.html.markdown. Entries should focus on the changes that users need to make when upgrading to 5.0.0, rather than how to write configurations after upgrading.\nSee Terraform provider for Google Cloud 4.0.0 Upgrade Guide and other upgrade guides for examples.\nThe upgrade guide and the actual breaking change will be merged only after both are completed.\nMake the breaking change on FEATURE-BRANCH-major-release-5.0.0 # When working on your breaking change, make sure that your base branch is FEATURE-BRANCH-major-release-5.0.0. This means that you will follow the standard contribution process with the following changes:\nBefore you start, check out and sync your local magic-modules and provider repositories with the upstream major release branches. cd ~/magic-modules git checkout FEATURE-BRANCH-major-release-5.0.0 git pull --ff-only origin FEATURE-BRANCH-major-release-5.0.0 cd $GOPATH/src/github.com/hashicorp/terraform-provider-google git checkout FEATURE-BRANCH-major-release-5.0.0 git pull --ff-only origin FEATURE-BRANCH-major-release-5.0.0 cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git checkout FEATURE-BRANCH-major-release-5.0.0 git pull --ff-only origin FEATURE-BRANCH-major-release-5.0.0 Make sure that any deprecation notices and warnings that you added in previous sections are present on the major release branch. Changes to the main branch will be merged into the major release branch every Monday. Make the breaking change. Remove any deprecation notices and warnings (including in documentation) not already removed by the breaking change. When you create your pull request, change the base branch to FEATURE-BRANCH-major-release-5.0.0 To resolve merge conflicts with git rebase or git merge, use FEATURE-BRANCH-major-release-5.0.0 instead of main. The upgrade guide and the actual breaking change will be merged only after both are completed.\nWhat\u0026rsquo;s next? # Run tests "},{"id":9,"href":"/magic-modules/reference/resource-reference/","title":"Resource YAML reference ↗","section":"Reference","content":"FORCE MENU RENDER\n"},{"id":10,"href":"/magic-modules/develop/test/run-tests/","title":"Run tests","section":"Test","content":" Run tests # Before you begin # Generate the modified provider(s)\nSet up application default credentials for Terraform\ngcloud auth application-default login export GOOGLE_USE_DEFAULT_CREDENTIALS=true Set the following environment variables:\nexport GOOGLE_PROJECT=PROJECT_ID export GOOGLE_REGION=us-central1 export GOOGLE_ZONE=us-central1-a Replace PROJECT_ID with the ID of the Google Cloud project you are using for testing.\nOptional: Some tests may require additional variables to be set, such as:\nGOOGLE_ORG GOOGLE_BILLING_ACCOUNT Run automated tests # GA Provider Run unit tests and linters\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google make test make lint Run acceptance tests for only modified resources. (Full test runs can take over 9 hours.) See Go\u0026rsquo;s documentation for more information about -run and other flags.\nmake testacc TEST=./google/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool\u0026#39; Optional: Save verbose test output (including API requests and responses) to a file for analysis.\nTF_LOG=DEBUG make testacc TEST=./google/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool_basic\u0026#39; \u0026gt; output.log Optional: Debug tests with Delve. See dlv test documentation for information about available flags.\ncd google TF_ACC=1 dlv test -- --test.v --test.run TestAccComputeRegionBackendService_withCdnPolicy Beta Provider Run unit tests and linters\ncd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta make test make lint Run acceptance tests for only modified resources. (Full test runs can take over 9 hours.) See Go\u0026rsquo;s documentation for more information about -run and other flags.\nmake testacc TEST=./google-beta/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool\u0026#39; Optional: Save verbose test output to a file for analysis.\nTF_LOG=DEBUG make testacc TEST=./google-beta/services/container TESTARGS=\u0026#39;-run=TestAccContainerNodePool_basic\u0026#39; \u0026gt; output.log Optional: Debug tests with Delve. See dlv test documentation for information about available flags.\ncd google-beta TF_ACC=1 dlv test -- --test.v --test.run TestAccComputeRegionBackendService_withCdnPolicy Optional: Test with different terraform versions # Tests will use whatever version of the terraform binary is found on your PATH. If you are testing a change that you know only impacts certain terraform versions, follow these steps:\nInstall tfenv.\nInstall the version of terraform you want to test.\ntfenv install VERSION Replace VERSION with the version you want to test.\nRun automated tests following the earlier section.\nOptional: Test manually # For manual testing, you can build the provider from source and run terraform apply to verify the behavior.\nBefore you begin # Configure Terraform to use locally-built binaries for google and google-beta instead of downloading the latest versions.\nDeveloper overrides (Mac / Linux) Find the location where built provider binaries are created. To do this, run this command and make a note of the path value:\ngo env GOBIN ## If the above returns nothing, then run the command below and add \u0026#34;/bin\u0026#34; to the end of the output path. go env GOPATH Create an empty configuration file.\n## create an empty file touch ~/tf-dev-override.tfrc ## open the file with a text editor of your choice, e.g: vi ~/tf-dev-override.tfrc Open the empty file with a text editor and paste in these contents:\nprovider_installation { # Developer overrides will stop Terraform from downloading the listed # providers their origin provider registries. dev_overrides { \u0026#34;hashicorp/google\u0026#34; = \u0026#34;GO_BIN_PATH/bin\u0026#34; \u0026#34;hashicorp/google-beta\u0026#34; = \u0026#34;GO_BIN_PATH/bin\u0026#34; } # For all other providers, install them directly from their origin provider # registries as normal. If you omit this, Terraform will _only_ use # the dev_overrides block, and so no other providers will be available. direct {} } Edit the file to replace GO_BIN_PATH with the path you saved from the first step, making sure to keep /bin at the end of the path.\nPlease note: the full path is required and environment variables cannot be used. For example, \u0026quot;/Users/UserName/go/bin\u0026quot; is a valid path for a user called UserName, but \u0026quot;~/go/bin\u0026quot; or \u0026quot;$HOME/go/bin\u0026quot; will not work.\nSave the file.\nDeveloper overrides (Windows) Find the location where built provider binaries are created. To do this, run this command and make a note of the path value:\necho %GOPATH% Create an empty configuration file in the %APPDATA% directory (use $env:APPDATA in PowerShell to find its location on your system).\n## create an empty file type nul \u0026gt; \u0026#34;$($env:APPDATA)\\tf-dev-override.tfrc\u0026#34; ## open the file with a text editor of your choice, e.g: notepad \u0026#34;$($env:APPDATA)\\tf-dev-override.tfrc\u0026#34; Open the empty file with a text editor and paste in these contents:\nprovider_installation { # Developer overrides will stop Terraform from downloading the listed # providers their origin provider registries. dev_overrides { \u0026#34;hashicorp/google\u0026#34; = \u0026#34;GO_BIN_PATH\\bin\u0026#34; \u0026#34;hashicorp/google-beta\u0026#34; = \u0026#34;GO_BIN_PATH\\bin\u0026#34; } # For all other providers, install them directly from their origin provider # registries as normal. If you omit this, Terraform will _only_ use # the dev_overrides block, and so no other providers will be available. direct {} } Edit the file to replace GO_BIN_PATH with the output you saved from the first step, making sure to keep \\bin at the end of the path.\nPlease note: The full path is required and environment variables cannot be used. For example, C:\\Users\\UserName\\go\\bin is a valid path for a user called UserName.\nSave the file.\nRun manual tests # Generate the provider(s) you want to test\nBuild the provider(s) you want to test\n## google provider cd $GOPATH/src/github.com/hashicorp/terraform-provider-google make build ## google-beta provider cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta make build Create a new directory and a main.tf file with your resource and its dependencies.\nIn the new directory, run terraform plan as follows:\nTF_CLI_CONFIG_FILE=\u0026#34;$HOME/tf-dev-override.tfrc\u0026#34; terraform plan Replace the TF_CLI_CONFIG_FILE value with the full path to your developer overrides file.\nOptional: Verify that developer overrides are working by looking for output like the following near the start of the output:\n│ Warning: Provider development overrides are in effect │ │ The following provider development overrides are set in the CLI configuration: │ - hashicorp/google in /Users/UserName/go/bin │ - hashicorp/google-beta in /Users/UserName/go/bin │ │ The behavior may therefore not match any released version of the provider and applying │ changes may cause the state to become incompatible with published releases. Run terraform apply with developer overrides.\nTF_CLI_CONFIG_FILE=\u0026#34;$HOME/tf-dev-override.tfrc\u0026#34; terraform apply Optional: Save verbose terraform apply output (including API requests and responses) to a file for analysis.\nTF_LOG=DEBUG TF_LOG_PATH=output.log TF_CLI_CONFIG_FILE=\u0026#34;$HOME/tf-dev-override.tfrc\u0026#34; terraform apply Cleanup # To stop using developer overrides, stop setting TF_CLI_CONFIG_FILE in the commands you are executing.\nTerraform will resume its normal behaviour of pulling published provider versions from the public Registry. Any version constraints in your Terraform configuration will come back into effect. Also, you may need to run terraform init to download the required version of the provider into your project directory if you haven\u0026rsquo;t already.\nWhat\u0026rsquo;s next? # Create a pull request "},{"id":11,"href":"/magic-modules/contribute/release-notes/","title":"Write release notes","section":"Contribute","content":" Write release notes # This guide explains best practices for composing accurate, end-user focused release notes for Magic Modules pull requests.\nEvery pull request must have at least one release note block in the opening comment. Release note blocks have the following format:\n```release-note:TYPE CONTENT ``` Replace TYPE with the correct release note type, and CONTENT with a release note written according to the guidelines in the following sections.\nGeneral guidelines # Do Don\u0026rsquo;t Only have one CONTENT line per release note block. Use multiple blocks if there are multiple related changes in a single PR. Don\u0026rsquo;t add multiple lines to a single release note block. Avoid combining multiple distinct types of changes into one release block. If a change only affects the google-beta provider add (beta) to the end of the release note. If a change only affects the google provider add (ga) to the end of the release note. Don\u0026rsquo;t add either suffix if the change affects both providers. Set an appropriate release note type. Don\u0026rsquo;t leave the type as REPLACEME. Type-specific guidelines and examples # New field(s) Write your release note in the following format:\n```release-note:enhancement PRODUCT: added `FIELD_1`, `FIELD_2`, and `FIELD_N` fields to `RESOURCE_NAME` resource ``` Replace PRODUCT, FIELD_*, and RESOURCE_NAME according to the pull request content. For example:\n```release-note:enhancement compute: added `foo_bar` field to `google_compute_foo` resource ``` New resource Write your release note in the following format:\n```release-note:new-resource `RESOURCE_NAME` ``` Replace RESOURCE_NAME according to the pull request content. For example:\n```release-note:new-resource `google_compute_new_resource` ``` New datasource Write your release note in the following format:\n```release-note:new-datasource `DATASOURCE_NAME` ``` Replace DATASOURCE_NAME according to the pull request content. For example:\n```release-note:new-datasource `google_compute_new_datasource` ``` Other Choose a release note type # For each release note block, choose an appropriate type from the following list:\nenhancement : New features on existing resources bug : Bug fix deprecation : A field/resource is being marked as deprecated (not being removed) breaking-change : Changes that require users to change their configuration note : General type for other notes that might be relevant to users but don\u0026rsquo;t fit into another category none : Changes where there is no user impact, like test fixes, website updates and CI changes. Release notes of this type should be empty. Guidelines # Do Don\u0026rsquo;t Use past tense to describe the end state after the change is released. Start with a verb. For example, \u0026ldquo;added\u0026hellip;\u0026rdquo;, \u0026ldquo;fixed\u0026hellip;\u0026rdquo;, or \u0026ldquo;resolved\u0026hellip;\u0026rdquo;. You can use future tense to describe future changes, such as saying that a deprecated field will be removed in a future version. Don\u0026rsquo;t use present or future tense to describe changes that are included in the pull request. Write user-focused release notes. For example, reference specific impacted terraform resource and field names, and discuss changes in behavior users will experience. Avoid API field/resource/feature names. Avoid implementation details. Avoid language that requires understanding of provider internals. Surround resource or field names with backticks. Don\u0026rsquo;t use resource or field names without punctuation or with other punctuation like quotation marks. Use impersonal third person. Don\u0026rsquo;t use \u0026ldquo;I\u0026rdquo;, \u0026ldquo;you\u0026rdquo;, etc. If the pull request impacts any specific, begin your release note with that product name followed by a colon. Use lower case for the first letter after the colon. For example, cloudrun: added... For MMv1 resources, use the folder name that contains the yaml files as the product name; for handwritten or tpgtools resources, use the API subdomain; for broad cross-product changes, use provider. Don\u0026rsquo;t begin your release note with the full resource name. Don\u0026rsquo;t add backticks around the product name. Don\u0026rsquo;t capitalize the first letter after the colon. Examples # ```release-note:bug cloudrun: fixed perma-diff in `google_cloud_run_service` ``` ```release-note:deprecation container: deprecated `region` and `zone` on `google_container_unicorn`. Use `location` instead. ``` "},{"id":12,"href":"/magic-modules/best-practices/","title":"Best practices","section":"Overview","content":" Best practices # The following is a list of best practices that contributions are expected to follow in order to ensure a consistent UX for the Terraform provider for Google Cloud internally and also compared to other Terraform providers.\nForceNew # ForceNew in a Terraform resource schema attribute that indicates that a field is immutable – that is, that a change to the field requires the resource to be destroyed and recreated.\nThis is necessary and required for cases where a field can\u0026rsquo;t be updated in-place, so that Terraform\u0026rsquo;s core workflow of aligning real infrastructure with configuration can be achieved. If a field or resource can never be updated in-place and is not marked with ForceNew, that is considered a bug in the provider.\nSome fields or resources may be possible to update in place, but only under specific conditions. In these cases, you can treat the field as updatable - that is, do not mark it as ForceNew; instead, implement standard update functionality. Then, call diff.ForceNew inside a CustomizeDiff if the appropriate conditions to allow update in place are not met. Any CustomizeDiff function like this must be thoroughly unit tested. Making a field conditionally updatable like this is considered a good and useful enhancement in cases where recreation is costly and conditional updates do not introduce undue complexity.\nIn complex cases, it is better to mark the field ForceNew to ensure that users can apply their configurations successfully.\nMitigating data loss risk via deletion_protection # Some resources, such as databases, have a significant risk of unrecoverable data loss if the resource is accidentally deleted due to a change to a ForceNew field. For these resources, the best practice is to add a deletion_protection field that defaults to true, which prevents the resource from being deleted if enabled. Although it is a small breaking change, for users, the benefits of deletion_protection defaulting to true outweigh the cost.\nAPIs also sometimes add deletion_protection fields, which will generally default to false for backwards-compatibility reasons. Any deletion_protection API field added to an existing Terraform resource must match the API default initially. The default may be set to true in the next major release. For new Terraform resources, any deletion_protection field should default to true in Terraform regardless of the API default. When creating the corresponding Terraform field, the name should match the API field name (i.e. it need not literally be named deletion_protection if the API uses something different) and should be the same field type (example: if the API field is an enum, so should the Terraform field).\nA resource can have up to two deletion_protection fields (with different names): one that represents a field in the API, and one that is only in Terraform. This could happen because the API added its field after deletion_protection already existed in Terraform; it could also happen because a separate field was added in Terraform to make sure that deletion_protection is enabled by default. In either case, they should be reconciled into a single field (that defaults to enabled and whose name matches the API field) in the next major release.\nResources that do not have a significant risk of unrecoverable data loss or similar critical concern will not be given deletion_protection fields.\nNote: The previous best practice was a field called force_delete that defaulted to false. This is still present on some resources for backwards-compatibility reasons, but deletion_protection is preferred going forward. Deletion policy # Some resources need to let users control the actions taken add deletion time. For these resources, the best practice is to add a deletion_policy enum field that defaults to an empty string and allows special values that control the deletion behavior.\nOne common example is ABANDON, which is useful if the resource is safe to delete from Terraform but could cause problems if deleted from the API - for example, google_bigtable_gc_policy deletion can fail in replicated instances. ABANDON indicates that attempts to delete the resource should remove it from state without actually deleting it.\nSee magic-modules#13107 for an example of adding a deletion_policy field to an existing resource.\nAdd labels and annotations support # The new labels model and the new annotations model are introduced in Terraform provider for Google Cloud 5.0.0.\nThere are now three label-related fields with the new labels model:\nThe labels field is now non-authoritative and only manages the label keys defined in your configuration for the resource. The terraform_labels cannot be specified directly by the user. It merges the labels defined in the resource\u0026rsquo;s configuration and the default labels configured in the provider block. If the same label key exists on both the resource level and provider level, the value on the resource will override the provider-level default. The output-only effective_labels will list all the labels present on the resource in GCP, including the labels configured through Terraform, the system, and other clients. There are now two annotation-related fields with the new annotations model:\nThe annotations field is now non-authoritative and only manages the annotation keys defined in your configuration for the resource. The output-only effective_annotations will list all the annotations present on the resource in GCP, including the annotations configured through Terraform, the system, and other clients. This document describes how to add labels and annotations field to resources to support the new models.\nLabels support # When adding a new labels field, please make the changes below to support the new labels model. Otherwise, it has to wait for the next major release to make the changes.\nMMv1 resources # Use the type KeyValueLabels for the standard resource labels field. The standard resource labels field could be the top level labels field or the nested labels field inside the top level metadata field. Don\u0026rsquo;t add default_from_api: true to this field or don\u0026rsquo;t use this type for other labels fields in the resource. KeyValueLabels will add all of changes required for the new model automatically. - !ruby/object:Api::Type::KeyValueLabels name: \u0026#39;labels\u0026#39; description: | The labels associated with this dataset. You can use these to organize and group your datasets. In the handwritten acceptance tests, add labels and terraform_labels to ImportStateVerifyIgnore if labels field is in the configuration. ImportStateVerifyIgnore: []string{\u0026#34;labels\u0026#34;, \u0026#34;terraform_labels\u0026#34;}, In the corresponding data source, after the resource read method, call the function tpgresource.SetDataSourceLabels(d) to make labels and terraform_labels have all of the labels on the resource. err = resourceArtifactRegistryRepositoryRead(d, meta) if err != nil { return err } if err := tpgresource.SetDataSourceLabels(d); err != nil { return err } Handwritten resources # Add tpgresource.SetLabelsDiff to CustomizeDiff of the resource. CustomizeDiff: customdiff.All( tpgresource.SetLabelsDiff, ), Add labels field and add more attributes (such as ForceNew: true,, Set: schema.HashString,) to this field if necessary. \u0026#34;labels\u0026#34;: { Type: schema.TypeMap, Optional: true, Elem: \u0026amp;schema.Schema{Type: schema.TypeString}, Description: `A set of key/value label pairs to assign to the project. **Note**: This field is non-authoritative, and will only manage the labels present in your configuration. Please refer to the field \u0026#39;effective_labels\u0026#39; for all of the labels present on the resource.`, }, Add output only field terraform_labels and add more attributes (such as Set: schema.HashString,) to this field if necessary. Don\u0026rsquo;t add ForceNew:true, to this field. \u0026#34;terraform_labels\u0026#34;: { Type: schema.TypeMap, Computed: true, Description: `The combination of labels configured directly on the resource and default labels configured on the provider.`, Elem: \u0026amp;schema.Schema{Type: schema.TypeString}, }, Add output only field effective_labels and add more attributes (such as ForceNew: true,, Set: schema.HashString,) to this field if necessary. \u0026#34;effective_labels\u0026#34;: { Type: schema.TypeMap, Computed: true, Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`, Elem: \u0026amp;schema.Schema{Type: schema.TypeString}, }, In the create method, use the value of effective_labels in API request. In the update method, use the value of effective_labels in API request. In the read mehtod, set labels, terraform_labels and effective_labels to state. if err := tpgresource.SetLabels(res.Labels, d, \u0026#34;labels\u0026#34;); err != nil { return fmt.Errorf(\u0026#34;Error setting labels: %s\u0026#34;, err) } if err := tpgresource.SetLabels(res.Labels, d, \u0026#34;terraform_labels\u0026#34;); err != nil { return fmt.Errorf(\u0026#34;Error setting terraform_labels: %s\u0026#34;, err) } if err := d.Set(\u0026#34;effective_labels\u0026#34;, res.Labels); err != nil { return fmt.Errorf(\u0026#34;Error setting effective_labels: %s\u0026#34;, err) } In the handwritten acceptance tests, add labels and terraform_labels to ImportStateVerifyIgnore. In the corresponding data source, after the resource read method, call the function tpgresource.SetDataSourceLabels(d) to make labels and terraform_labels have all of the labels on the resource. Add the documentation for these label-related fields. Annotations support # When adding a new annotations field, please make the changes below below to support the new annotations model. Otherwise, it has to wait for the next major release to make the breaking changes.\nMMv1 resources # Use the type KeyValueAnnotations for the standard resource annotations field. The standard resource annotations field could be the top level annotations field or the nested annotations field inside the top level metadata field. Don\u0026rsquo;t add default_from_api: true to this field or don\u0026rsquo;t use this type for other annotations fields in the resource. KeyValueAnnotations will add all of changes required for the new model automatically. - !ruby/object:Api::Type::KeyValueAnnotations name: \u0026#39;annotations\u0026#39; description: \u0026#39;Client-specified annotations. This is distinct from labels.\u0026#39; In the handwritten acceptance tests, add annotations to ImportStateVerifyIgnore if annotations field is in the configuration. ImportStateVerifyIgnore: []string{\u0026#34;annotations\u0026#34;}, In the corresponding data source, after the resource read method, call the function tpgresource.SetDataSourceAnnotations(d) to make annotations have all of the annotations on the resource. err = resourceSecretManagerSecretRead(d, meta) if err != nil { return err } if err := tpgresource.SetDataSourceLabels(d); err != nil { return err } if err := tpgresource.SetDataSourceAnnotations(d); err != nil { return err } Handwritten resources # Add tpgresource.SetAnnotationsDiff to CustomizeDiff of the resource. Add annotations field and add more attributes (such as ForceNew: true,, Set: schema.HashString,) to this field if necessary. Add output only field effective_annotations and add more attributes (such as ForceNew: true,, Set: schema.HashString,) to this field if necessary. In the create method, use the value of effective_annotations in API request. In the update method, use the value of effective_annotations in API request. In the read mehtod, set annotations, and effective_annotations to state. In the handwritten acceptance tests, add annotations to ImportStateVerifyIgnore. In the corresponding data source, after the resource read method, call the function tpgresource.SetDataSourceAnnotations(d) to make annotations have all of the labels on the resource. Add the documentation for these annotation-related fields. "},{"id":13,"href":"/magic-modules/develop/resource/","title":"Add or modify a resource","section":"Develop","content":" Add or modify a resource # This page describes how to add a new resource to the google or google-beta Terraform provider using MMv1 and/or handwritten code.\nFor more information about types of resources and the generation process overall, see How Magic Modules works.\nBefore you begin # Complete the Generate the providers quickstart to set up your environment and your Google Cloud project. Ensure that your magic-modules, terraform-provider-google, and terraform-provider-google-beta repositories are up to date. cd ~/magic-modules git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull Add a resource # MMv1 Using an editor of your choice, in the appropriate product folder, create a file called RESOURCE_NAME.yaml. Replace RESOURCE_NAME with the name of the API resource you are adding support for. For example, a configuration file for NatAddress would be called NatAddress.yaml.\nCopy the following template into the new file:\n# Copyright 2024 Google Inc. # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. --- !ruby/object:Api::Resource # API resource name name: \u0026#39;ResourceName\u0026#39; # Resource description for the provider documentation. description: | RESOURCE_DESCRIPTION references: !ruby/object:Api::Resource::ReferenceLinks guides: # Link to quickstart in the API\u0026#39;s Guides section. For example: # \u0026#39;Create and connect to a database\u0026#39;: \u0026#39;https://cloud.google.com/alloydb/docs/quickstart/create-and-connect\u0026#39; \u0026#39;QUICKSTART_TITLE\u0026#39;: \u0026#39;QUICKSTART_URL\u0026#39; # Link to the REST API reference for the resource. For example, # https://cloud.google.com/alloydb/docs/reference/rest/v1/projects.locations.backups api: \u0026#39;API_REFERENCE_URL\u0026#39; # Marks the resource as beta-only. Ensure a beta version block is present in # provider.yaml. # min_version: beta # Inserts styled markdown into the header of the resource\u0026#39;s page in the # provider documentation. # docs: !ruby/object:Provider::Terraform::Docs # warning: | # MULTILINE_WARNING_MARKDOWN # note: | # MULTILINE_NOTE_MARKDOWN # URL for the resource\u0026#39;s standard List method. https://google.aip.dev/132 # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. base_url: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames\u0026#39; # URL for the resource\u0026#39;s standard Get method. https://google.aip.dev/131 # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. self_link: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames/{{name}}\u0026#39; # If true, the resource and all its fields are considered immutable - that is, # only creatable, not updatable. Individual fields can override this if they # have a custom update method in the API. # immutable: true # Overrides one or more timeouts, in minutes. All timeouts default to 20. # timeouts: !ruby/object:Api::Timeouts # insert_minutes: 20 # update_minutes: 20 # delete_minutes: 20 # URL for the resource\u0026#39;s standard Create method, including query parameters. # https://google.aip.dev/133 # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. create_url: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames?resourceId={{name}}\u0026#39; # Overrides the HTTP verb used to create a new resource. # Allowed values: :POST, :PUT, :PATCH. Default: :POST # create_verb: :POST # Overrides the URL for the resource\u0026#39;s standard Update method. (If unset, the # self_link URL is used by default.) https://google.aip.dev/134 # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. # update_url: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames/{{name}}\u0026#39; # The HTTP verb used to update a resource. Allowed values: :POST, :PUT, :PATCH. Default: :PUT. update_verb: :PATCH # If true, the resource sets an `updateMask` query parameter listing modified # fields when updating the resource. If false, it does not. update_mask: true # Overrides the URL for the resource\u0026#39;s standard Delete method. (If unset, the # self_link URL is used by default.) https://google.aip.dev/135 # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. # delete_url: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames/{{name}}\u0026#39; # Overrides the HTTP verb used to delete a resource. # Allowed values: :POST, :PUT, :PATCH, :DELETE. Default: :DELETE # delete_verb: :DELETE # If true, code for handling long-running operations is generated along with # the resource. If false, that code is not generated. autogen_async: true # Sets parameters for handling operations returned by the API. async: !ruby/object:Api::OpAsync # Overrides which API calls return operations. Default: [\u0026#39;create\u0026#39;, # \u0026#39;update\u0026#39;, \u0026#39;delete\u0026#39;] # actions: [\u0026#39;create\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;delete\u0026#39;] operation: !ruby/object:Api::OpAsync::Operation base_url: \u0026#39;{{op_id}}\u0026#39; # If true, the provider sets the resource\u0026#39;s Terraform ID after the resource is created, # taking into account values that are set by the API at create time. This is only possible # when the completed operation\u0026#39;s JSON includes the created resource in the \u0026#34;response\u0026#34; field. # If false (or unset), the provider sets the resource\u0026#39;s Terraform ID before the resource is # created, based only on the resource configuration. # result: !ruby/object:Api::OpAsync::Result # resource_inside_response: true # All resources (of all kinds) that share a mutex value block rather than # executing concurrent API requests. # Terraform field names enclosed in double curly braces are replaced with # the field values from the resource at runtime. # mutex: RESOURCE_NAME/{{name}} parameters: - !ruby/object:Api::Type::String name: \u0026#39;location\u0026#39; required: true immutable: true url_param_only: true description: | LOCATION_DESCRIPTION - !ruby/object:Api::Type::String name: \u0026#39;name\u0026#39; required: true immutable: true url_param_only: true description: | NAME_DESCRIPTION properties: # Fields go here Modify the template as needed to match the API resource\u0026rsquo;s documented behavior.\nDelete all remaining comments in the resource configuration (including attribute descriptions) that were copied from the above template.\nNote: The template includes the most commonly-used fields. For a comprehensive reference, see ResourceName.yaml reference ↗.\nHandwritten Warning: Handwritten resources are more difficult to develop and maintain. New handwritten resources will only be accepted if implementing the resource in MMv1 would require entirely overriding two or more CRUD methods.\nAdd the resource in MMv1. Generate the beta provider From the beta provider, copy the files generated for the resource to the following locations: Resource: Copy to the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services Documentation: magic-modules/mmv1/third_party/terraform/website/docs/r Tests: Copy to the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services, and remove _generated from the filename Sweepers: magic-modules/mmv1/third_party/terraform/utils Modify the Go code as needed. Replace all occurrences of github.com/hashicorp/terraform-provider-google-beta/google-beta with github.com/hashicorp/terraform-provider-google/google Remove the Example suffix from all test function names. Remove the comments at the top of the file. If beta-only fields are being tested, do the following: Change the file suffix to .go.erb Add \u0026lt;% autogen_exception -%\u0026gt; to the top of the file Wrap each beta-only test in a separate version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt; Register the resource handwrittenResources in magic-modules/mmv1/third_party/terraform/provider/provider_mmv1_resources.go.erb Add a version guard for any beta-only resources. Optional: Complete other handwritten tasks that require the MMv1 configuration file. Add resource tests Add IAM support Delete the MMv1 configuration file. Add fields # In general, Terraform resources should implement all configurable fields and all read-only fields. Even fields that seem like they would not be useful in Terraform (like update time or etag) often end up being requested by users, so it\u0026rsquo;s usually easier to just add them all at once. However, optional or read-only fields can be omitted when adding a resource if they would require significant additional work to implement.\nMMv1 For each API field, copy the following template into the resource\u0026rsquo;s properties attribute. Be sure to indent appropriately. Simple - !ruby/object:Api::Type::String name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION min_version: beta immutable: true required: true output: true conflicts: - field_one - nested_object.0.nested_field exactly_one_of: - field_one - nested_object.0.nested_field Replace String in the field type with one of the following options:\nString Integer Boolean Double KeyValuePairs (string -\u0026gt; string map) KeyValueLabels (for standard resource \u0026rsquo;labels\u0026rsquo; field) KeyValueAnnotations (for standard resource \u0026lsquo;annotations\u0026rsquo; field) Enum - !ruby/object:Api::Type::Enum name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION min_version: beta immutable: true required: true output: true conflicts: - field_one - nested_object.0.nested_field exactly_one_of: - field_one - nested_object.0.nested_field values: - :VALUE_ONE - :VALUE_TWO ResourceRef - !ruby/object:Api::Type::ResourceRef name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION min_version: beta immutable: true required: true output: true conflicts: - field_one - nested_object.0.nested_field exactly_one_of: - field_one - nested_object.0.nested_field resource: \u0026#39;ResourceName\u0026#39; imports: \u0026#39;name\u0026#39; Array - !ruby/object:Api::Type::Array name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION min_version: beta immutable: true required: true output: true conflicts: - field_one - nested_object.0.nested_field exactly_one_of: - field_one - nested_object.0.nested_field # Array of primitives item_type: Api::Type::String # Array of nested objects item_type: !ruby/object:Api::Type::NestedObject properties: - !ruby/object:Api::Type::String name: \u0026#39;FIELD_NAME\u0026#39; description: | MULTI_LINE_FIELD_DESCRIPTION NestedObject - !ruby/object:Api::Type::Array name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION min_version: beta immutable: true required: true output: true conflicts: - field_one - nested_object.0.nested_field exactly_one_of: - field_one - nested_object.0.nested_field properties: - !ruby/object:Api::Type::String name: \u0026#39;FIELD_NAME\u0026#39; description: | MULTI_LINE_FIELD_DESCRIPTION Map - !ruby/object:Api::Type::Map name: \u0026#39;API_FIELD_NAME\u0026#39; description: | MULTILINE_FIELD_DESCRIPTION key_name: KEY_NAME key_description: | MULTILINE_KEY_FIELD_DESCRIPTION value_type: !ruby/object:Api::Type::NestedObject properties: - !ruby/object:Api::Type::String name: \u0026#39;FIELD_NAME\u0026#39; description: | MULTI_LINE_FIELD_DESCRIPTION This type is only used for string -\u0026gt; complex type mappings, use \u0026ldquo;KeyValuePairs\u0026rdquo; for simple mappings. Complex maps can\u0026rsquo;t be represented natively in Terraform, and this type is transformed into an associative array (TypeSet) with the key merged into the object alongside other top-level fields.\nFor key_name and key_description, provide a domain-appropriate name and description. For example, a map that references a specific type of resource would generally use the singular resource kind as the key name (such as \u0026ldquo;topic\u0026rdquo; for PubSub Topic) and a descriptor of the expected format depending on the context (such as resourceId vs full resource name).\nModify the field configuration according to the API documentation and behavior. Note: The templates in this section only include the most commonly-used fields. For a comprehensive reference, see MMv1 field reference. For information about modifying the values sent and received for a field, see Modify the API request or response.\nHandwritten Add the field to the handwritten resource\u0026rsquo;s schema. The new field(s) should mirror the API\u0026rsquo;s structure to ease predictability and maintenance. However, if there is an existing related / similar field in the resource that uses a different convention, follow that convention instead. Enum fields in the API should be represented as TypeString in Terraform for forwards-compatibility. Link to the API documentation of allowed values in the field description. Terraform field names should always use snake case ↗. See Schema Types ↗ and Schema Behaviors ↗ for more information about field schemas. Add handling for the new field in the resource\u0026rsquo;s Create method and Update methods. \u0026ldquo;Expanders\u0026rdquo; convert Terraform resource data to API request data. For top level fields, add an expander. If the field is set or has changed, call the expander and add the resulting value to the API request. For other fields, add logic to the parent field\u0026rsquo;s expander to add the field to the API request. Use a nested expander for complex logic. Add handling for the new field in the resource\u0026rsquo;s Read method. \u0026ldquo;Flatteners\u0026rdquo; convert API response data to Terraform resource data. For top level fields, add a flattener. Call d.Set() on the flattened API response value to store it in Terraform state. For other fields, add logic to the parent field\u0026rsquo;s flattener to convert the value from the API response to the Terraform state value. Use a nested flattener for complex logic. If any of the added Go code (including any imports) is beta-only, change the file suffix to .go.erb and wrap the beta-only code in a version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt;. Add a new guard rather than adding the field to an existing guard; it is easier to read. Add IAM support # This section covers how to add IAM resources in Terraform if they are supported by a particular API resource (indicated by setIamPolicy and getIamPolicy methods in the API documentation for the resource).\nMMv1 Add the following top-level block to ResourceName.yaml directly above parameters. iam_policy: !ruby/object:Api::Resource::IamPolicy # Name of the field on the terraform IAM resources which references # the parent resource. Update to match the parent resource\u0026#39;s name. parent_resource_attribute: \u0026#39;resource_name\u0026#39; # Character preceding setIamPolicy in the full URL for the API method. # Usually `:` method_name_separator: \u0026#39;:\u0026#39; # HTTP method for getIamPolicy. Usually :POST. # Allowed values: :GET, :POST. Default: :GET fetch_iam_policy_verb: :POST # Overrides the HTTP method for setIamPolicy. # Allowed values: :POST, :PUT. Default: :POST # set_iam_policy_verb: :POST # Must match the parent resource\u0026#39;s `import_format` (or `self_link` if # `import_format` is unset), but with the `parent_resource_attribute` # value substituted for the final field. import_format: [ \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames/{{resource_name}}\u0026#39; ] # Valid IAM role that can be set by generated tests. Default: \u0026#39;roles/viewer\u0026#39; # allowed_iam_role: \u0026#39;roles/viewer\u0026#39; # If IAM conditions are supported, set this attribute to indicate how the # conditions should be passed to the API. Allowed values: :QUERY_PARAM, # :REQUEST_BODY, :QUERY_PARAM_NESTED. Note: :QUERY_PARAM_NESTED should # only be used if the query param field contains a `.` # iam_conditions_request_type: :REQUEST_BODY # Marks IAM support as beta-only # min_version: beta Modify the template as needed to match the API resource\u0026rsquo;s documented behavior. These are the most commonly-used fields. For a comprehensive reference, see IAM policy YAML reference ↗. Delete all remaining comments in the IAM configuration (including attribute descriptions) that were copied from the above template. Handwritten Warning: IAM support for handwritten resources should be implemented using MMv1. New handwritten IAM resources will only be accepted if they cannot be implemented using MMv1.\nAdd support in MMv1 # Follow the MMv1 directions in Add the resource to create a skeleton ResourceName.yaml file for the handwritten resource, but set only the following top-level fields: name description (required but unused) base_url (set to URL of IAM parent resource) self_link (set to same value as base_url) id_format (set to same value as base_url) import_format (including base_url value) exclude_resource (set to true) properties Follow the MMv1 directions in Add fields to add only the fields used by base_url. Follow the MMv1 directions in this section to add IAM support. Convert to handwritten (not usually necessary) # Generate the beta provider From the beta provider, copy the files generated for the IAM resources to the following locations: Resource: Copy to the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services Documentation: magic-modules/mmv1/third_party/terraform/website/docs/r Tests: In the appropriate service folder inside magic-modules/mmv1/third_party/terraform/services Modify the Go code as needed. Replace all occurrences of github.com/hashicorp/terraform-provider-google-beta/google-beta with github.com/hashicorp/terraform-provider-google/google Remove the comments at the top of the file. If any of the added Go code is beta-only: Change the file suffix to .go.erb Add \u0026lt;% autogen_exception -%\u0026gt; to the top of the file Wrap each beta-only code block (including any imports) in a separate version guard: \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% else -%\u0026gt;...\u0026lt;% end -%\u0026gt; Register the binding, member, and policy resources handwrittenIAMResources in magic-modules/mmv1/third_party/terraform/provider/provider_mmv1_resources.go.erb Add a version guard for any beta-only resources. Add documentation # MMv1 Documentation is autogenerated based on the resource and field configurations. To preview the documentation:\nGenerate the providers Copy and paste the generated documentation into the Hashicorp Registry\u0026rsquo;s Doc Preview Tool to see how it is rendered. Handwritten Add or modify documentation files # Open the resource documentation in magic-modules/third_party/terraform/website/docs/r/ using an editor of your choice. The name of the file is the name of the resource without a google_ prefix. For example, for google_compute_instance, the file is called compute_instance.html.markdown Modify the documentation as needed according to Handwritten documentation style guide. Generate the providers Copy and paste the generated documentation into the Hashicorp Registry\u0026rsquo;s Doc Preview Tool to see how it is rendered. What\u0026rsquo;s next? # Add custom resource code Add tests Run tests "},{"id":14,"href":"/magic-modules/contribute/","title":"Contribute","section":"Overview","content":""},{"id":15,"href":"/magic-modules/reference/iam-policy-reference/","title":"IAM policy YAML reference ↗","section":"Reference","content":"FORCE MENU RENDER\n"},{"id":16,"href":"/magic-modules/contribute/review-pr/","title":"Review a pull request","section":"Contribute","content":" Review a pull request # This page provides guidelines for reviewing a Magic Modules pull request (PR).\nRead the PR description to understand the context and ensure the PR either is linked to a GitHub issue or an internal bug if not, check the issue tracker to see whether the feature has already been requested and add the issues in the description, if any. establishes clear context itself via title or description. If the PR adds any new resource, ensure that the resource does not already exists in the GA provider or beta provider Read through all the changes in the PR, generated code in the downstreams and the API documentation to ensure that: the resource schema added in the PR matches the API structure. the features are added in the correct version features only available in beta are not included in the GA google provider. features added to the GA provider are also included in the beta provider \u0026ndash; beta should be a strict superset of GA. no breaking changes are introduced without a valid justification. Add the override-breaking-change label if there is a valid justification. remember to check for changes in default behaviour like changing the flags on delete! verify the change fully resolves the linked issues, if any. If it does not, change the \u0026ldquo;Fixes\u0026rdquo; message to \u0026ldquo;Part of\u0026rdquo;. Check the tests added/modified to ensure that: all fields added/updated in the PR appear in at least one test. It is advisable to test updating from a non-zero value to a zero value if feasible. all mutable fields are tested in at least one update test. all resources in the acceptance tests have a tf-test or tf_test prefix in their primary id field. all handwritten test Config steps include import steps following them all related tests pass in GA for features promoted from beta to GA. Note: Presubmit VCR tests do not run in GA. Manual testing is required for promoted GA features. newly added or modified diff suppress functions are tested in at least one unit test. the linked issue (if any) is covered by at least one test that reproduces the issue for example - a bugfix should test the bug (or explain why it\u0026rsquo;s not feasible to do so in the description, including manual results when possible) and an enhancement should test the new behaviour(s). all related PR presubmit tests have been completed successfully, including: terraform-provider-breaking-change-test presubmit-rake-tests terraform-provider-google-build-and-unit-tests terraform-provider-google-beta-build-and-unit-tests VCR-test Note: Some acceptance tests may be skipped in VCR and manual testing is required. a significant number of preexisting tests have not been modified. Changing old tests often indicates a change is backwards incompatible. Check documentation to ensure resouce-level and field-level documentation are generated correctly for MMv1-based resource documentation is added manually for handwritten resources. Check if release notes capture all changes in the PR, and are correctly formatted following the guidance in write release notes before merge the PR. "},{"id":17,"href":"/magic-modules/develop/field-reference/","title":"MMv1 field reference","section":"Develop","content":" MMv1 field reference # This page documents commonly-used properties for fields. For a full list of available properties, see type.rb ↗.\nShared properties # min_version: beta # Marks the field (and any subfields) as beta-only. Ensure a beta version block is present in provider.yaml. Do not use if an ancestor field (or the overall resource) is already marked as beta-only.\nimmutable # If true, the field (and any subfields) are considered immutable - that is, only settable on create. If unset or false, the field is still considered immutable if any ancestor field (or the overall resource) is immutable, unless update_url is set.\nExample:\nimmutable: true update_url # If set, changes to the field\u0026rsquo;s value trigger a separate call to a specific API method for updating the field\u0026rsquo;s value. The field is not considered immutable even if an ancestor field (or the overall resource) is immutable. Terraform field names enclosed in double curly braces are replaced with the field values from the resource at runtime.\nExample:\nupdate_url: \u0026#39;projects/{{project}}/locations/{{location}}/resourcenames/{{name}}/setFieldName\u0026#39; update_verb # If update_url is also set, overrides the verb used to update this specific field. Allowed values: :POST, :PUT, :PATCH. Default: Resource\u0026rsquo;s update_verb (which defaults to :PUT if unset).\nExample:\nupdate_verb: :POST required # If true, the field is required. If unset or false, the field is optional.\nExample:\nrequired: true output # If true, the field is output-only - that is, it cannot be configured by the user. If unset or false, the field is configurable.\nExample:\noutput: true sensitive # If true, the field is considered \u0026ldquo;sensitive\u0026rdquo;, which means that its value will be obscured in Terraform output such as plans. If false, the value will not be obscured. Either way, the value will still be stored in plaintext in Terraform state. See Handling Sensitive Values in State for more information.\nSensitive fields are often not returned by the API (because they are sensitive). In this case, the field will also need to use ignore_read or a custom_flatten function.\nExample:\nsensitive: true ignore_read # If true, the provider sets the field\u0026rsquo;s value in the resource state based only on the user\u0026rsquo;s configuration. If false or unset, the provider sets the field\u0026rsquo;s value in the resource state based on the API response. Only use this attribute if the field cannot be read from GCP due to either API or provider constraints.\nNested fields currently do not support ignore_read but can replicate the behavior by implementing a custom_flatten that always ignores the value returned by the API. Example. Any fields using a custom flatten also need to be added to ignore_read_extra for any examples where the field is set.\nExample: YAML\nignore_read: true Example: Custom flatten\nfunc flatten\u0026lt;%= prefix -%\u0026gt;\u0026lt;%= titlelize_property(property) -%\u0026gt;(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { return d.Get(\u0026#34;password\u0026#34;) } default_value # Sets a client-side default value for the field. This should be used if the API has a default value that applies in all cases and is stable. Removing or changing a default value is a breaking change. If unset, the field defaults to an \u0026ldquo;empty\u0026rdquo; value (such as zero, false, or an empty string).\nExample:\ndefault_value: DEFAULT_VALUE default_from_api # If true, and the field is either not set or set to an \u0026ldquo;empty\u0026rdquo; value (such as zero, false, or empty strings), the provider accepts any value returned from the API as the value for the field. If false, and the field is either not set or set to an \u0026ldquo;empty\u0026rdquo; value, the provider treats the field\u0026rsquo;s default_value as the value for the field and shows a diff if the API returns any other value for the field. This attribute is useful for complex or frequently-changed API-side defaults, but provides less useful information at plan time than default_value and causes the provider to ignore user configurations that explicitly set the field to an \u0026ldquo;empty\u0026rdquo; value. default_from_api and send_empty_value cannot both be true on the same field.\nExample:\ndefault_from_api: true send_empty_value # If true, the provider sends \u0026ldquo;empty\u0026rdquo; values (such as zero, false, or empty strings) to the API if set explicitly in the user\u0026rsquo;s configuration. If false, \u0026ldquo;empty\u0026rdquo; values cause the field to be omitted entirely from the API request. This attribute is useful for fields where the API would behave differently for an \u0026ldquo;empty\u0026rdquo; value vs no value for a particular field - for example, boolean fields that have an API-side default of true. send_empty_value and default_from_api cannot both be true on the same field.\nExample:\nsend_empty_value: true conflicts # Specifies a list of fields (excluding the current field) that cannot be specified at the same time as the current field. Must be set separately on all listed fields. Not supported within lists of nested objects.\nExample:\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; conflicts: - field_two - nested_object.0.nested_field exactly_one_of # Specifies a list of fields (including the current field) of which exactly one must be set. Must be set separately on all listed fields. Not supported within lists of nested objects.\nExample:\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; exactly_one_of: - field_one - field_two - nested_object.0.nested_field at_least_one_of # Specifies a list of fields (including the current field) that cannot be specified at the same time (but at least one of which must be set). Must be set separately on all listed fields. Not supported within lists of nested objects.\nExample:\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; at_least_one_of: - field_one - field_two - nested_object.0.nested_field diff_suppress_func # Specifies the name of a diff suppress function to use for this field. In many cases, a custom flattener is preferred because it will allow the user to see a clearer diff when the field actually is being changed. See Fix a permadiff for more information and best practices.\nThe function specified can be a provider-specific function (for example, tgpresource.CaseDiffSuppress) or a function defined in resource-specific custom code.\nExample:\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; diff_suppress_func: \u0026#39;tpgresource.CaseDiffSuppress\u0026#39; validation # Controls the value set for the field\u0026rsquo;s ValidateFunc.\nIf validation is set on an Enum field, it will override the default validation (that the provided value is in the Enum\u0026rsquo;s values).\nThis property has two mutually exclusive child properties:\nfunction: The name of a validation function to use for validation. The function can be a Terraform-provided function (for example, validation.IntAtLeast(0)), a provider-specific function (for example, verify.ValidateBase64String), or a function defined in resource-specific custom code. regex: A regex string to check values against. This can only be used on simple String fields. It is equivalent to function: verify.ValidateRegexp(REGEX_STRING). Example: Provider-specific function\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; validation: !ruby/object:Provider::Terraform::Validation function: \u0026#39;verify.ValidateBase64String\u0026#39; Example: Regex\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; validation: !ruby/object:Provider::Terraform::Validation regex: \u0026#39;^[a-zA-Z][a-zA-Z0-9_]*$\u0026#39; api_name # Specifies a name to use for communication with the API that is different than the name of the field in Terraform. In general, setting an api_name is not recommended, because it makes it more difficult for users and maintainers to understand how the resource maps to the underlying API.\n- !ruby/object:Api::Type::String name: \u0026#39;fieldOne\u0026#39; api_name: \u0026#39;otherFieldName\u0026#39; Enum properties # values # Enum only. Sets allowed values as ruby \u0026ldquo;literal constants\u0026rdquo; (prefixed with a colon). If the allowed values change frequently, use a String field instead to allow better forwards-compatibility, and link to API documentation stating the current allowed values in the String field\u0026rsquo;s description. Do not include UNSPECIFIED values in this list.\nEnums will validate that the provided field is in the allowed list unless a custom validation is provided.\nExample:\nvalues: - :VALUE_ONE - :VALUE_TWO Array properties # item_type # Array only. Sets the expected type of the items in the array. Primitives should use the name of the primitive class as a string; other types should define the attributes of the nested type.\nExample: Primitive value\nitem_type: Api::Type::String Example: Enum value\nitem_type: !ruby/object:Api::Type::Enum name: \u0026#39;required but unused\u0026#39; description: \u0026#39;required but unused\u0026#39; values: - :VALUE_ONE - :VALUE_TWO Example: Nested object\nitem_type: !ruby/object:Api::Type::NestedObject properties: - !ruby/object:Api::Type::String name: \u0026#39;FIELD_NAME\u0026#39; description: | MULTI_LINE_FIELD_DESCRIPTION NestedObject properties # properties # NestedObject only. Defines fields nested inside the current field.\nExample:\nproperties: - !ruby/object:Api::Type::String name: \u0026#39;FIELD_NAME\u0026#39; description: | MULTI_LINE_FIELD_DESCRIPTION "},{"id":18,"href":"/magic-modules/develop/custom-code/","title":"Add custom resource code","section":"Develop","content":" Add custom resource code # This document covers how to add \u0026ldquo;custom code\u0026rdquo; to MMv1 resources. Custom code can be used to add arbitrary logic to a resource while still generating most of the code; it allows for a balance between maintainability and supporting real-worlds APIs that deviate from what MMv1 can support. Custom code should only be added if the desired behavior can\u0026rsquo;t be achieved otherwise.\nMost custom code attributes are strings that contain a path to a template file relative to the mmv1 directory. For example:\ncustom_code: !ruby/object:Provider::Terraform::CustomCode # References mmv1/templates/terraform/custom_delete/resource_name_custom_delete.go.erb custom_delete: templates/terraform/custom_delete/resource_name_custom_delete.go.erb By convention, the template files are stored in a directory matching the type of custom code, and the name of the file includes the resource (and, if relevant, field) impacted by the custom code. Like handwritten resource and test code, custom code is written as ruby templates which render go code.\nWhen in doubt about the behavior of custom code, write the custom code, generate the providers, and inspect what changed in the providers using git diff.\nThe following sections describe types of custom code in more detail.\nAdd reusable variables and functions # custom_code: !ruby/object:Provider::Terraform::CustomCode constants: templates/terraform/constants/PRODUCT_RESOURCE.go.erb Use custom_code.constants to inject top-level code in a resource file. This is useful for anything that should be referenced from other parts of the resource, such as:\nConstants Regexes compiled at build time Functions, such as diff suppress functions Methods Modify the API request or response # API requests and responses can be modified in the following order:\nModify the API request value for a specific field Modify the API request data for an entire resource Modify the API response data for an entire resource Modify the API response value for a specific field These are described in more detail in the following sections.\nModify the API request value for a specific field # - !ruby/object:Api::Type::String name: \u0026#39;FIELD\u0026#39; custom_expand: \u0026#39;templates/terraform/custom_expand/PRODUCT_RESOURCE_FIELD.go.erb\u0026#39; Set custom_expand on a field to inject code that modifies the value to send to the API for that field. Custom expanders run before any encoder or update_encoder. The referenced file must include the function signature for the expander. For example:\nfunc expand\u0026lt;%= prefix -%\u0026gt;\u0026lt;%= titlelize_property(property) -%\u0026gt;(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) { if v == nil { return nil, nil } return base64.StdEncoding.EncodeToString([]byte(v.(string))), nil } The parameters the function receives are:\nv: The value for the field d: Terraform resource data. Use d.Get(\u0026quot;field_name\u0026quot;) to get a field\u0026rsquo;s current value. config: Config object. Can be used to make API calls. The function returns a final value that will be sent to the API.\nModify the API request data for an entire resource # custom_code: !ruby/object:Provider::Terraform::CustomCode encoder: templates/terraform/encoder/PRODUCT_RESOURCE.go.erb update_encoder: templates/terraform/update_encoder/PRODUCT_RESOURCE.go.erb Use custom_code.encoder to inject code that modifies the data that will be sent in the API request. This is useful if the API expects the data to be in a significantly different structure than Terraform does - for example, if the API expects the entire object to be nested under a key, or a particular field must never be sent to the API. The encoder will run after any custom_expand code.\nThe encoder code will be wrapped in a function like:\nfunc resourceProductResourceEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) { // Your code will be injected here. } The parameters the function receives are:\nd: Terraform resource data. Use d.Get(\u0026quot;field_name\u0026quot;) to get a field\u0026rsquo;s current value. meta: Can be cast to a Config object (which can make API calls) using meta.(*transport_tpg.Config) obj: The data that will be sent to the API. The function returns data that will be sent to the API and an optional error.\nIf the Create and Update methods for the resource need different logic, set custom_code.update_encoder to override the logic for update only. It is otherwise the same as custom_code.encoder.\nModify the API response data for an entire resource # custom_code: !ruby/object:Provider::Terraform::CustomCode decoder: templates/terraform/decoder/PRODUCT_RESOURCE.go.erb Use custom_code.decoder to inject code that modifies the data that will be sent in the API request. This is useful if the API expects the data to be in a significantly different structure than Terraform does - for example, if the API returns the entire object nested under a key, or uses a different name for a field in the response than in the request. The decoder will run before any custom_flatten code.\nThe decoder code will be wrapped in a function like:\nfunc resourceProductResourceDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) { // Your code will be injected here. } The parameters the function receives are:\nd: Terraform resource data. Use d.Get(\u0026quot;field_name\u0026quot;) to get a field\u0026rsquo;s current value. meta: Can be cast to a Config object (which can make API calls) using meta.(*transport_tpg.Config) res: The data (\u0026ldquo;response\u0026rdquo;) returned by the API. The function returns data that will be set in Terraform state and an optional error.\nModify the API response value for a specific field # - !ruby/object:Api::Type::String name: \u0026#39;FIELD\u0026#39; custom_flatten: \u0026#39;templates/terraform/custom_flatten/PRODUCT_RESOURCE_FIELD.go.erb\u0026#39; Set custom_flatten on a field to inject code that modifies the value returned by the API prior to storing it in Terraform state. Custom flatteners run after any decoder. The referenced file must include the function signature for the flattener. For example:\nfunc flatten\u0026lt;%= prefix -%\u0026gt;\u0026lt;%= titlelize_property(property) -%\u0026gt;(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { if v == nil { return \u0026#34;0\u0026#34; } return v } The parameters the function receives are:\nv: The value for the field d: Terraform resource data. Use d.Get(\u0026quot;field_name\u0026quot;) to get a field\u0026rsquo;s current value. config: Config object. Can be used to make API calls. The function returns a final value that will be stored in Terraform state for the field, which will be compared with the user\u0026rsquo;s configuration to determine if there is a diff.\nInject code before / after CRUD operations and Import # custom_code: !ruby/object:Provider::Terraform::CustomCode pre_create: templates/terraform/pre_create/PRODUCT_RESOURCE.go.erb post_create: templates/terraform/post_create/PRODUCT_RESOURCE.go.erb pre_read: templates/terraform/pre_read/PRODUCT_RESOURCE.go.erb pre_update: templates/terraform/pre_update/PRODUCT_RESOURCE.go.erb post_update: templates/terraform/post_update/PRODUCT_RESOURCE.go.erb pre_delete: templates/terraform/pre_delete/PRODUCT_RESOURCE.go.erb post_delete: templates/terraform/post_delete/PRODUCT_RESOURCE.go.erb post_import: templates/terraform/post_import/PRODUCT_RESOURCE.go.erb CRUD operations can be modified with pre/post hooks. This code will be injected directly into the relevant CRUD method as close as possible to the related API call and will have access to any variables that are present when it runs. pre_create and pre_update run after any encoder. Some example use cases:\nUse post_create to set an update-only field after create finishes. Use pre_delete to detach a disk before deleting it. Use post_import to parse attributes from the import ID and call d.Set(\u0026quot;field\u0026quot;) so that the resource can be read from the API. Custom create error handling # custom_code: !ruby/object:Provider::Terraform::CustomCode post_create_failure: templates/terraform/post_create_failure/PRODUCT_RESOURCE.go.erb Use custom_code.post_create_failure to inject code that runs if a Create request to the API returns an error.\nThe post_create_failure code will be wrapped in a function like:\nfunc resourceProductResourcePostCreateFailure(d *schema.ResourceData, meta interface{}) { // Your code will be injected here. } The parameters the function receives are:\nd: Terraform resource data. Use d.Get(\u0026quot;field_name\u0026quot;) to get a field\u0026rsquo;s current value. meta: Can be cast to a Config object (which can make API calls) using meta.(*transport_tpg.Config) Replace entire CRUD methods # custom_code: !ruby/object:Provider::Terraform::CustomCode custom_create: templates/terraform/custom_create/PRODUCT_RESOURCE.go.erb custom_update: templates/terraform/custom_update/PRODUCT_RESOURCE.go.erb custom_delete: templates/terraform/custom_delete/PRODUCT_RESOURCE.go.erb custom_import: templates/terraform/custom_import/PRODUCT_RESOURCE.go.erb Custom methods replace the entire contents of the Create, Update, Delete, or Import methods. For example:\nfunc resourceProductResourceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) { // Your code will be injected here. } Custom methods are similar to handwritten code and should be avoided if possible. If you have to replace two or more methods, the resource should be handwritten instead.\nAdd extra fields to a resource # Use custom_code.extra_schema_entry to add additional fields to a resource. Do not use extra_schema_entry unless there is no other option. The extra fields are injected at the end of the resource\u0026rsquo;s Schema field. They should be formatted as entries in the map. For example:\n\u0026#34;foo\u0026#34;: \u0026amp;schema.Schema{ ... }, Any fields added in this way will need to be have documentation manually added using the top-level docs field:\ndocs: !ruby/object:Provider::Terraform::Docs optional_properties: | * `FIELD_NAME` - (Optional, [Beta](https://terraform.io/docs/providers/google/guides/provider_versions.html)) FIELD_DESCRIPTION See Add documentation (Handwritten) for more information about what to include in the field documentation.\nWhat\u0026rsquo;s next? # Add tests Run tests "},{"id":19,"href":"/magic-modules/develop/add-handwritten-datasource/","title":"Add a datasource","section":"Develop","content":" Add a datasource # Note: only handwritten datasources are currently supported\nDatasources are like terraform resources except they don\u0026rsquo;t create anything. They are simply read-only operations that will expose some sort of values needed for subsequent resource operations. If you\u0026rsquo;re adding a field to an existing datasource, check the Resource section. Everything there will be mostly consistent with the type of change you\u0026rsquo;ll need to make. For adding a new datasource there are 5 steps to doing so.\nCreate a new datasource declaration file and a corresponding test file Add Schema and Read operation implementation If there is labels field with type KeyValueLabels in the corresponding resource, in the datasource Read operation implementation, after the resource read method, call the function tpgresource.SetDataSourceLabels(d) to make labels and terraform_labels have all of the labels on the resource. If there is annotations field with type KeyValueAnnotations in the corresponding resource, in the datasource Read operation implementation, after the resource read method, call the function tpgresource.SetDataSourceAnnotations(d) to make annotations have all of the annotations on the resource. Register the datasource to handwrittenDatasources in magic-modules/mmv1/third_party/terraform/provider/provider_mmv1_resources.go.erb Implement a test which will create and resources and read the corresponding datasource Add documentation For creating a datasource based off an existing resource you can make use of the schema directly. Otherwise implementing the schema directly, similar to normal resource creation, is the desired path.\nResourceless Datasources # Datasources not backed by a resource are possible to add as well. They follow the same general steps as adding a resource-based datasource, except that a full Read method will need to be defined for them rather than calling a resource\u0026rsquo;s Read method.\nNote that while resource-based datasources can depend on the resource read method for API calls, resourceless datasources need to make them themselves. An HTTP-based client that\u0026rsquo;s properly configured with logging and retries must be used, such as a client from the https://github.com/googleapis/google-api-go-client library, or the raw HTTP client used in MMV1 through SendRequest.\nAdd documentation # Open the data source documentation in magic-modules/third_party/terraform/website/docs/d/ using an editor of your choice. The name of the file is the name of the data source without a google_ prefix. For example, for google_compute_instance, the file is called compute_instance.html.markdown Modify the documentation as needed according to Handwritten documentation style guide. Generate the providers Copy and paste the generated documentation into the Hashicorp Registry\u0026rsquo;s Doc Preview Tool to see how it is rendered. "},{"id":20,"href":"/magic-modules/reference/","title":"Reference","section":"Overview","content":""},{"id":21,"href":"/magic-modules/get-started/contribution-process/","title":"Contribution process","section":"Get started","content":" Contribution process # Before you begin # Familiarize yourself with GitHub flow Fork the Magic Modules repository into your GitHub account Set up your development environment Check whether the feature you want to work on has already been requested in the issue tracker. If there\u0026rsquo;s an issue and it already has a dedicated assignee, this indicates that someone might have already started to work on a solution. Otherwise, you\u0026rsquo;re welcome to work on the issue. Contribute code # Create a new branch for your change Make the code change. For example: Add or modify a resource Add resource tests Add a datasource Promote to GA Make a breaking change Generate the providers that include your change. Run provider tests locally that are relevant to the change you made Create a pull request (PR) Make changes in response to code review After your change is merged # After your change is merged, it can take a week or longer to be released to customers.\n"},{"id":22,"href":"/magic-modules/develop/promote-to-ga/","title":"Promote to GA","section":"Develop","content":" Promote from beta to GA # This document describes how to promote an existing resource or field that uses MMv1 and/or handwritten code from the google-beta provider to the google (also known as \u0026ldquo;GA\u0026rdquo;) provider.\nHandwritten code (including custom_code) commonly uses \u0026ldquo;version guards\u0026rdquo; in the form of \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% end -%\u0026gt; to wrap code that is beta-specific, which need to be removed during promotion.\nFor more information about types of resources and the generation process overall, see How Magic Modules works.\nBefore you begin # Complete the Generate the providers quickstart to set up your environment and your Google Cloud project. Ensure that your magic-modules, terraform-provider-google, and terraform-provider-google-beta repositories are up to date. cd ~/magic-modules git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull cd $GOPATH/src/github.com/hashicorp/terraform-provider-google-beta git checkout main \u0026amp;\u0026amp; git clean -f . \u0026amp;\u0026amp; git checkout -- . \u0026amp;\u0026amp; git pull Promote fields and resources # MMv1 Remove min_version: beta from the resource\u0026rsquo;s or field\u0026rsquo;s configuration in ResourceName.yaml. If necessary, remove version guards from resource-level custom_code. Add min_version: beta on any fields or subfields that should not be promoted. If necessary, add \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% end -%\u0026gt; version guards to resource-level custom_code that should not be promoted. Handwritten Remove version guards from the resource\u0026rsquo;s implementation for any functionality being promoted. Be sure to check: The overall resource (if the entire resource was beta-only) The resource schema For top-level fields, the resource\u0026rsquo;s Create, Update, and Read methods For other fields, expanders and flatteners Any other resource-specific code Add \u0026lt;% unless version == 'ga' -%\u0026gt;...\u0026lt;% end -%\u0026gt; version guards to any parts of the resource or field implementation that should not be promoted. Be sure to check: The resource schema For top-level fields, the resource\u0026rsquo;s Create, Update, and Read methods For other fields, expanders and flatteners Any other resource-specific code Promote tests # Remove min_version: beta from any examples in a ResourceName.yaml which only test fields and resources that are present in the google provider. Remove version guards from any handwritten code related to fields and resources that are present in the google provider. Remove provider = google-beta from any test configurations (from MMv1 examples or handwritten) which have been promoted. Ensure that there is at least one test that will run for the google provider that covers any promoted fields and resources. Promote documentation # For handwritten resources, modify the documentation as appropriate for your change:\nIf the entire resource has been promoted to google, remove the beta warning at the top of the documentation.\nRemove the Beta annotation for any fields that have been promoted.\nAdd Beta as an annotation on any fields or subfields that remained beta-only. For example:\n* `FIELD_NAME` - (Optional, [Beta](https://terraform.io/docs/providers/google/guides/provider_versions.html)) FIELD_DESCRIPTION Replace FIELD_NAME and FIELD_DESCRIPTION with the field\u0026rsquo;s name and description.\nWhat\u0026rsquo;s next? # Test your changes "},{"id":23,"href":"/magic-modules/develop/permadiff/","title":"Fix a permadiff","section":"Develop","content":" Fix a permadiff # Permadiffs are an extremely common class of errors that users experience. They manifest as diffs at plan time on fields that a user has not modified in their configuration. They can also show up as test failures with the error message: \u0026ldquo;After applying this test step, the plan was not empty.\u0026rdquo;\nIn a general sense, permadiffs are caused by the API returning a different value for the field than what the user sent, which causes Terraform to try to re-send the same request, which gets the same response, which continues to result in the user seeing a diff. In general, APIs that return exactly what the user sent are more friendly for Terraform or other declarative tooling. However, many GCP APIs normalize inputs, have server-side defaults that are returned to the user, do not return all the fields set on a resource, or return data in a different format in some other way.\nThis page outlines best practices for working around various types of permadiffs in the google and google-beta providers.\nAPI returns default value for unset field # For new fields, if possible, set a client-side default that matches the API default. This will prevent the diff and will allow users to accurately see what the end state will be if the field is not set in their configuration. A client-side default should only be used if the API sets the same default value in all cases and the default value will be stable over time. Changing a client-side default is a breaking change.\nMMv1 default_value: DEFAULT_VALUE In the providers, this will be converted to:\n\u0026#34;field\u0026#34;: { // ... Default: \u0026#34;DEFAULT_VALUE\u0026#34;, } See SDKv2 Schema Behaviors - Default ↗ for more information.\nHandwritten \u0026#34;field\u0026#34;: { // ... Default: \u0026#34;DEFAULT_VALUE\u0026#34;, } See SDKv2 Schema Behaviors - Default ↗ for more information.\nFor existing fields (or new fields that are not eligible for a client-side default), mark the field as having an API-side default. If the field is not set (or is set to an \u0026ldquo;empty\u0026rdquo; value such as zero, false, or an empty string) the provider will treat the most recent value returned by the API as the value for the field, and will send that value for the field on subsequent requests. The field will show as (known after apply) in plans and it will not be possible for the user to explicitly set the field to an \u0026ldquo;empty\u0026rdquo; value.\nMMv1 default_from_api: true In the providers, this will be converted to:\n\u0026#34;field\u0026#34;: { // ... Optional: true, Computed: true, } See SDKv2 Schema Behaviors - Optional ↗ and SDKv2 Schema Behaviors - Computed ↗ for more information.\nHandwritten \u0026#34;field\u0026#34;: { // ... Optional: true, Computed: true, } See SDKv2 Schema Behaviors - Optional ↗ and SDKv2 Schema Behaviors - Computed ↗ for more information.\nAPI returns an empty value if default value is sent # Use a flattener to store the default value in state if the response has an empty (or unset) value.\nMMv1 Use the standard default_if_empty flattener.\ncustom_flatten: \u0026#39;templates/terraform/custom_flatten/default_if_empty.erb\u0026#39; Handwritten func flattenResourceNameFieldName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { if v == nil || tpgresource.IsEmptyValue(reflect.ValueOf(v)) { return \u0026#34;DEFAULT_VALUE\u0026#34; } // Any other necessary logic goes here. return v } API normalizes a value # In cases where the API normalizes and returns a value in a simple, predictable way (such as capitalizing the value) add a diff suppress function for the field to suppress the diff.\nThe tpgresource package in each provider supplies diff suppress functions for the following common cases:\ntpgresource.CaseDiffSuppress: Suppress diffs from capitalization differences between the user\u0026rsquo;s configuration and the API. tpgresource.DurationDiffSuppress: Suppress diffs from duration format differences such as \u0026ldquo;60.0s\u0026rdquo; vs \u0026ldquo;60s\u0026rdquo;. This is necessary for Duration API fields. tpgresource.ProjectNumberDiffSuppress: Suppress diffs caused by the provider sending a project ID and the API returning a project number. MMv1 # Use a built-in function diff_suppress_func: tpgresource.CaseDiffSuppress # Reference a resource-specific function diff_suppress_func: resourceNameFieldNameDiffSuppress Define resource-specific functions in a custom_code.constants file.\nfunc resourceNameFieldNameDiffSuppress(_, old, new string, _ *schema.ResourceData) bool { // Separate function for easier unit testing return resourceNameFieldNameDiffSuppressLogic(old, new) } func resourceNameFieldNameDiffSuppressLogic(old, new) bool { // Diff suppression logic. Returns true if the diff should be suppressed - that is, if the // old and new values should be considered \u0026#34;the same\u0026#34;. } See SDKv2 Schema Behaviors - DiffSuppressFunc ↗ for more information.\nHandwritten Define resource-specific functions in your service package, for example at the top of the related resource file.\nfunc resourceNameFieldNameDiffSuppress(_, old, new string, _ *schema.ResourceData) bool { // Separate function for easier unit testing return resourceNameFieldNameDiffSuppressLogic(old, new) } func resourceNameFieldNameDiffSuppressLogic(old, new) bool { // Diff suppression logic. Returns true if the diff should be suppressed - that is, if the // old and new values should be considered \u0026#34;the same\u0026#34;. } Reference diff suppress functions from the field definition.\n\u0026#34;field\u0026#34;: { // ... DiffSuppressFunc: resourceNameFieldNameDiffSuppress, } See SDKv2 Schema Behaviors - DiffSuppressFunc ↗ for more information.\nAPI field that is never included in the response # This is common for fields that store credentials or similar information. Such fields should also be marked as sensitive.\nIn the flattener for the field, return the value of the field in the user\u0026rsquo;s configuration.\nMMv1 On top-level fields, this can be done with:\nignore_read: true For nested fields, ignore_read is not currently supported, so this must be implemented with a custom flattener. You will also need to add the field to ignore_read_extra on any examples that are used to generate tests; this will cause tests to ignore the field when checking that the values in the API match the user\u0026rsquo;s configuration.\nfunc flatten\u0026lt;%= prefix -%\u0026gt;\u0026lt;%= titlelize_property(property) -%\u0026gt;(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { // We want to ignore read on this field, but cannot because it is nested return d.Get(\u0026#34;path.0.to.0.nested.0.field\u0026#34;) } examples: - !ruby/object:Provider::Terraform::Examples # example configuration ignore_read_extra: - \u0026#34;path.0.to.0.nested.0.field\u0026#34; Handwritten Use d.Get to set the flattened value to be the same as the user-configured value (instead of a value from the API).\nfunc flattenParentField(d *schema.ResourceData, disk *compute.AttachedDisk, config *transport_tpg.Config) []map[string]interface{} { result := map[string]interface{}{ \u0026#34;nested_field\u0026#34;: d.Get(\u0026#34;path.0.to.0.parent_field.0.nested_field\u0026#34;) } return []map[string]interface{}{result} } In tests, add the field to ImportStateVerifyIgnore on any relevant import steps.\n{ ResourceName: \u0026#34;google_product_resource.default\u0026#34;, ImportState: true, ImportStateVerify: true, ImportStateVerifyIgnore: []string{\u0026#34;\u0026#34;path.0.to.0.parent_field.0.nested_field\u0026#34;}, }, API returns a list in a different order than was sent # For an Array of unique string values (or nested objects with unique string identifiers), use the SortStringsByConfigOrder or SortMapsByConfigOrder helper functions to sort the API response to match the order in the user\u0026rsquo;s configuration. This will also simplify diffs if new values are added or removed. Imported resources will not have access to a configuration, so the field will be sorted alphabetically. This means that tests for the resource need to ignore the field\u0026rsquo;s import behavior via ignore_read_extra (for MMv1 examples) or ImportStateVerifyIgnore (for handwritten tests).\nMMv1 Add a custom flattener for the field.\nfunc flatten\u0026lt;%= prefix -%\u0026gt;\u0026lt;%= titlelize_property(property) -%\u0026gt;(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { configValue := d.Get(\u0026#34;path.0.to.0.parent_field.0.nested_field\u0026#34;).([]string) sorted, err := tpgresource.SortStringsByConfigOrder(configValue, v.([]string)) if err != nil { log.Printf(\u0026#34;[ERROR] Could not sort API response value: %s\u0026#34;, err) return v } return sorted.(interface{}) } Handwritten Define resource-specific functions in your service package, for example at the top of the related resource file.\nfunc flattenResourceNameFieldName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} { configValue := d.Get(\u0026#34;path.0.to.0.parent_field.0.nested_field\u0026#34;).([]string) sorted, err := tpgresource.SortStringsByConfigOrder(configValue, v.([]string)) if err != nil { log.Printf(\u0026#34;[ERROR] Could not sort API response value: %s\u0026#34;, err) return v } return sorted.(interface{}) } For other Array fields, convert the field to a Set – this is a breaking change and can only happen in a major release.\n"},{"id":24,"href":"/magic-modules/develop/test/","title":"Test","section":"Develop","content":""},{"id":25,"href":"/magic-modules/develop/breaking-changes/","title":"Breaking changes","section":"Develop","content":""},{"id":26,"href":"/magic-modules/develop/handwritten-docs-style-guide/","title":"Handwritten docs style guide","section":"Develop","content":" Handwritten documentation style guide # This document describes the style guide for handwritten documentation for resources and data sources. MMv1-based resources will automatically generate documentation that matches this style guide.\nFile name and location # Handwritten documentation lives in:\nData sources: magic-modules/third_party/terraform/website/docs/d/ Resources: magic-modules/third_party/terraform/website/docs/r/ The name of the file is the name of the resource without a google_ prefix. For example, for google_compute_instance, the file is called compute_instance.html.markdown\nYAML frontmatter # Every resource or datasource documentation page must include YAML frontmatter which sets subcategory (where the page will be displayed in the left sidebar).\n--- subcategory: Cloud Foobar --- Callouts # Use callouts for important information.\n-\u0026gt; **Note** This callout is blue ~\u0026gt; **Note** This callout is yellow !\u0026gt; **Warning** This callout is red Sections # Every resource or datasource documentation page must include the following sections as described in Hashicorp\u0026rsquo;s Documenting Providers: Resource/Data Source Headers\nTitle and description. Include a general description of the resource or data source and links to the official product usage documentation and REST API reference. Example:\n# google\\_cloud\\_run\\_locations Get Cloud Run locations available for a project. To get more information about Cloud Run, see: * [API documentation](https://cloud.google.com/run/docs/reference/rest/v1/projects.locations) * How-to Guides * [Official Documentation](https://cloud.google.com/run/docs/) For beta-only resources or data sources, add the following snippet at the end of this section:\nResource ~\u0026gt; **Warning:** This resource is in beta, and should be used with the terraform-provider-google-beta provider. See [Provider Versions](https://terraform.io/docs/providers/google/guides/provider_versions.html) for more details on beta resources. Data source ~\u0026gt; **Warning:** This data source is in beta, and should be used with the terraform-provider-google-beta provider. See [Provider Versions](https://terraform.io/docs/providers/google/guides/provider_versions.html) for more details on beta resources. Example Usage. Include a minimal set of examples showing how to use the resource or data source.\nArgument Reference. List settable fields on the datasource. For example:\n## Argument Reference The following arguments are supported: * `name` - (Required) Name of the resource. - - - * `project` - (Optional) The ID of the project in which the resource belongs. If it is not provided, the provider project is used. * `beta_field` - (Optional, [Beta](https://terraform.io/docs/providers/google/guides/provider_versions.html)) This field is in beta. * `roles` - The MembershipRoles that apply to the Membership. Structure is [documented below](#nested_roles). \u0026lt;a name=\u0026#34;nested_roles\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;The `roles` block supports: * `name` - The name of the MembershipRole. One of OWNER, MANAGER, MEMBER. Attribute Reference. List all output-only fields.\n## Attribute Reference In addition to the arguments listed above, the following computed attributes are exported: * `create_time` - (Output) The time when the repository was created. Note: If a data source is a read-only version of a resource, instead provide a link to the resource documentation to avoid duplicating information:\n## Attribute Reference See [google_FOOBAR](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/FOOBAR#argument-reference) for details of the available attributes. If relevant, also include the following sections:\nTimeouts (example) Import (example) User Project Overrides (example) "}]